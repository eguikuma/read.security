---
layout: default
title: サプライチェーンセキュリティ（依存の信頼）
---

# [07-supply-chain：サプライチェーンセキュリティ（依存の信頼）](#supply-chain) {#supply-chain}

## [はじめに](#introduction) {#introduction}

前のトピック [06-application-security](../06-application-security/) では、アプリケーションセキュリティの仕組みを学びました

- アプリケーションセキュリティの基本原則は「入力を信頼しない」であり、すべての外部入力は潜在的に悪意があるという前提で処理する
- インジェクション攻撃の根本原因は「コードとデータの境界の混同」であり、SQL インジェクション、XSS、コマンドインジェクション、プロンプトインジェクションに共通する
- SQL インジェクションはパラメータ化クエリで防御し、XSS は出力エンコーディングで防御する
- CSRF は認証済みセッションを悪用した攻撃であり、CSRF トークンと SameSite Cookie で防御する
- 入力検証（許可リスト方式）と出力エンコーディング（コンテキストに応じたエスケープ）を組み合わせて防御する
- 多層防御は単一の防御に依存しない設計原則であり、1 つの層が破られても他の層が防御を継続する
- OWASP Top 10 は Web アプリケーションの重大なセキュリティリスクを体系化したフレームワークである

06-application-security の最後に、こう問いかけました

<strong>アプリケーションのコード自体が安全でも、そのアプリケーションが依存するライブラリやフレームワークに悪意あるコードが含まれていた場合、どのように防御するのでしょうか？</strong>

アプリケーションは多くの外部ライブラリに依存しており、それらのライブラリがさらに別のライブラリに依存していますが、この「依存の連鎖」の安全性はどのように確保されるのでしょうか？

ビルドパイプラインやパッケージレジストリが改ざんされた場合、どのような影響が出るのでしょうか？

このトピックでは、<strong>サプライチェーンセキュリティ</strong>の仕組みを学びます

ソフトウェアが依存するライブラリ、ビルドシステム、配布経路の全体をどのように信頼し、その信頼をどのように検証するのか、その原理を理解します

---

## [日常の例え](#everyday-analogy) {#everyday-analogy}

サプライチェーンセキュリティの仕組みを、日常の例えで見てみましょう

<strong>ソフトウェアサプライチェーン = 食品の原材料サプライチェーン</strong>

レストランは、すべての食材を自ら育てているわけではありません

野菜は農家から、肉は畜産業者から、調味料は食品メーカーから仕入れます

もし農家で使われた農薬に問題があれば、その野菜を使ったすべてのレストランの料理が影響を受けます

レストラン自身は何も間違っていなくても、仕入れ先（サプライチェーン）の問題がそのまま影響するのです

ソフトウェアも同じです

アプリケーションは多くの外部ライブラリに依存しており、そのライブラリに脆弱性があれば、アプリケーション全体が影響を受けます

<strong>推移的依存関係 = 食品の原材料表示</strong>

ケーキに使われているチョコレートには、カカオ、砂糖、乳化剤が含まれています

そのカカオはどの農園で栽培され、砂糖はどの工場で精製されたのでしょうか

1 つの原材料の中に、さらに多くの「原材料の原材料」が隠れています

ソフトウェアの依存関係も同じです

あなたが直接使うライブラリ（直接依存）が、内部で別のライブラリ（推移的依存）を使っており、その先にもさらに依存関係が続きます

どこか 1 つに問題があれば、連鎖的に影響が広がります

<strong>ソフトウェア署名 = 食品のトレーサビリティシール</strong>

有機野菜には、どの農園で栽培され、どの流通経路を通って届いたかを証明するトレーサビリティシールが貼られています

このシールは「誰が作ったか」「途中で改ざんされていないか」を確認するための仕組みです

ソフトウェア署名も同じ役割を果たします

「誰がビルドしたか」「配布の途中で改ざんされていないか」を暗号的に検証できるようにする仕組みです

<strong>xz-utils バックドア = 信頼された料理人による毒入れ</strong>

有名レストランの料理長が、長年にわたって信頼を築いてきたとします

ある日、その料理長が少しずつ有害な食材を料理に混ぜ始めたらどうなるでしょうか

客はレストランを信頼し、レストランは料理長を信頼しているため、誰も気づきません

xz-utils バックドア事件はまさにこの構造です

信頼されたメンテナの地位を悪用して、悪意あるコードを少しずつ挿入しました

---

## [このページで学ぶこと](#what-you-will-learn) {#what-you-will-learn}

<strong>ソフトウェアサプライチェーンの構造</strong>

- <strong>ソフトウェアサプライチェーンとは</strong>
  - ソースコード、依存関係、ビルド、配布、デプロイの一連の流れ
- <strong>推移的依存関係</strong>
  - 直接依存が間接依存を生む連鎖構造

<strong>サプライチェーンへの攻撃</strong>

- <strong>依存関係を狙う攻撃</strong>
  - パッケージの改ざん、タイポスクワッティング、依存関係の混同
- <strong>メンテナの信頼を悪用する攻撃</strong>
  - 信頼されたメンテナの地位を利用したバックドアの挿入
- <strong>ビルドパイプラインへの攻撃</strong>
  - ビルドシステムの改ざんによるソースコードと成果物の不一致

<strong>サプライチェーンの防御</strong>

- <strong>ソフトウェア署名と検証</strong>
  - 成果物の出所と改ざんの有無を暗号的に検証する仕組み
- <strong>SLSA フレームワーク</strong>
  - サプライチェーンの各段階の信頼性を段階的に高めるフレームワーク
- <strong>OWASP Top 10 との対応</strong>
  - A03（ソフトウェアサプライチェーンの障害）と A08（ソフトウェアまたはデータの完全性の障害）

---

## [目次](#table-of-contents) {#table-of-contents}

1. [なぜサプライチェーンセキュリティが必要か](#why-supply-chain-security)
2. [ソフトウェアサプライチェーンとは](#what-is-software-supply-chain)
3. [依存関係の信頼と推移的依存関係](#dependency-trust)
4. [メンテナの信頼とソースコードの改ざん](#maintainer-trust-and-tampering)
5. [パッケージレジストリへの攻撃](#package-registry-attacks)
6. [ビルドの完全性](#build-integrity)
7. [ソフトウェア署名と検証](#software-signing)
8. [SLSA フレームワーク](#slsa)
9. [コンテナイメージの信頼](#container-image-trust)
10. [OWASP Top 10 との対応](#owasp-top-10-correspondence)
11. [防御レイヤの全体像：01 から 07 まで](#defense-layer-overview)
12. [まとめ：このリポジトリで学んだこと](#repository-learning-summary)
13. [用語集](#glossary)
14. [参考資料](#references)

---

## [なぜサプライチェーンセキュリティが必要か](#why-supply-chain-security) {#why-supply-chain-security}

### [これまでの防御レイヤ](#defense-layers-so-far) {#defense-layers-so-far}

このリポジトリでは、セキュリティの防御レイヤを 1 つずつ積み重ねてきました

```
  これまでに学んだ防御レイヤ：

  ┌────────────────────────────────────────────┐
  │ サプライチェーンの防御                        │ ← このトピック
  ├────────────────────────────────────────────┤
  │ アプリケーションの防御                        │ ← 06 で学んだ
  ├────────────────────────────────────────────┤
  │ アクセス制御（誰が何をできるか）               │ ← 05 で学んだ
  ├────────────────────────────────────────────┤
  │ 認証（あなたは誰か）                          │ ← 04 で学んだ
  ├────────────────────────────────────────────┤
  │ 証明書と PKI（信頼の連鎖）                    │ ← 03 で学んだ
  ├────────────────────────────────────────────┤
  │ TLS（通信路の保護）                           │ ← 02 で学んだ
  ├────────────────────────────────────────────┤
  │ 暗号化（機密性・完全性・真正性）                │ ← 01 で学んだ
  └────────────────────────────────────────────┘
```

[01-cryptography](../01-cryptography/) でデータを暗号化し、[02-tls](../02-tls/) で通信路を保護し、[03-certificate](../03-certificate/) でサーバーの身元を確認し、[04-authentication](../04-authentication/) でユーザーの身元を確認し、[05-access-control](../05-access-control/) でアクセス権限を管理し、[06-application-security](../06-application-security/) で悪意ある入力から防御しました

### [信頼の前提](#trust-assumption) {#trust-assumption}

しかし、これらの防御レイヤには共通する前提があります

<strong>ソフトウェア自体が信頼できること</strong>です

01 から 06 までの防御は「通信が安全か」「ユーザーが正当か」「入力が安全か」という問いに答えるものです

しかし、「アプリケーション自体（コード、ライブラリ、ビルドツール）が信頼できるか」という問いには答えていません

もしアプリケーションが依存するライブラリに悪意あるコードが含まれていれば、01 から 06 までの防御をすべて通過した後で、内部から攻撃が発生します

これは根本的に異なる脅威モデルです

攻撃は信頼境界の外側からではなく、<strong>信頼境界の内側</strong>から来ます

### [拡大するサプライチェーン攻撃](#expanding-supply-chain-attacks) {#expanding-supply-chain-attacks}

サプライチェーン攻撃の対象は、ソースコード、依存関係、ビルドシステム、配布チャネルのすべてです

[03-certificate](../03-certificate/) で学んだ PKI の信頼モデルを思い出してください

認証局（CA）が侵害されると、その CA が発行したすべての証明書の信頼が崩壊しました

サプライチェーン攻撃も同じ構造です

信頼されたコンポーネント（ライブラリ、メンテナ、ビルドシステム）が侵害されると、そのコンポーネントに依存するすべてのソフトウェアの信頼が崩壊します

---

## [ソフトウェアサプライチェーンとは](#what-is-software-supply-chain) {#what-is-software-supply-chain}

### [サプライチェーンの構成要素](#supply-chain-components) {#supply-chain-components}

ソフトウェアサプライチェーンとは、ソースコードの作成からユーザーへの配布までの一連の流れです

```
  ソフトウェアサプライチェーンの流れ：

  ソースコード → 依存関係の解決 → ビルド → 配布 → デプロイ

  開発者が       外部ライブラリ    コンパイル    レジストリや    実行環境に
  コードを書く    を取得する       やパッケージ   CDN で公開     展開する
                                  ングする      する
```

各段階は独立した関係者やシステムによって運営されており、それぞれが潜在的な攻撃対象です

### [各段階の脅威](#stage-threats) {#stage-threats}

{: .labeled}
| 段階 | 内容 | 脅威の例 |
| -------------- | -------------------------- | ---------------------------------------------- |
| ソースコード | 開発者が書くコード | メンテナのアカウント侵害、悪意あるコミット |
| 依存関係の解決 | 使用する外部ライブラリ | 改ざんされたパッケージ、タイポスクワッティング |
| ビルド | コンパイルとパッケージング | ビルドシステムの改ざん、再現性のないビルド |
| 配布 | レジストリや CDN | レジストリの侵害、パッケージのすり替え |
| デプロイ | 実行環境への展開 | 改ざんされたイメージ、検証なしのデプロイ |

### [依存関係の爆発](#dependency-explosion) {#dependency-explosion}

現代のソフトウェアは、膨大な数の外部ライブラリに依存しています

1 回の `npm install` や `pip install` で、数百のパッケージがインストールされることは珍しくありません

それぞれのパッケージは異なる開発者やチームによってメンテナンスされており、セキュリティ対策のレベルもさまざまです

信頼しなければならない対象の範囲が非常に広いことが、サプライチェーンセキュリティの根本的な課題です

---

## [依存関係の信頼と推移的依存関係](#dependency-trust) {#dependency-trust}

### [直接依存と推移的依存](#direct-and-transitive-dependency) {#direct-and-transitive-dependency}

アプリケーションが明示的に宣言する依存関係を<strong>直接依存</strong>（Direct Dependency）といいます

直接依存が内部で使用する依存関係を<strong>推移的依存</strong>（Transitive Dependency）といいます

```
  依存関係のツリー：

  あなたのアプリケーション
       │
       ├── ライブラリ A（直接依存）
       │     ├── ライブラリ C（推移的依存）
       │     └── ライブラリ D（推移的依存）
       │           └── ライブラリ F（推移的依存）
       │
       └── ライブラリ B（直接依存）
             └── ライブラリ E（推移的依存）
                   └── ライブラリ F（推移的依存）
```

この例では、直接依存は A と B の 2 つですが、推移的依存を含めると C、D、E、F の 4 つが加わり、合計 6 つのライブラリに依存しています

依存の連鎖が深くなるほど、開発者の可視性と制御は低下します

### [Log4Shell：推移的依存関係の事例](#log4shell-case) {#log4shell-case}

2021 年に発見された Log4Shell（CVE-2021-44228）は、推移的依存関係の危険性を示す代表的な事例です

Log4j は Java のログ出力ライブラリであり、多くの Java アプリケーションやフレームワークが内部で使用していました

この脆弱性は、特殊な文字列をログに記録するだけでリモートコード実行が可能になるという深刻なものでした

```
  Log4Shell の影響範囲：

  あなたのアプリケーション
       │
       └── Web フレームワーク（直接依存）
             │
             └── Log4j（推移的依存）← 脆弱性
                   │
                   ▼
             リモートコード実行が可能に
```

多くの組織は、自分たちのアプリケーションが Log4j に依存していることすら把握していませんでした

Log4j は直接依存ではなく、フレームワークやライブラリが内部で使用する推移的依存だったためです

この事例が示す教訓は明確です

<strong>依存関係ツリー全体の安全性に責任を持つ必要がある</strong>ということです

直接宣言したライブラリだけでなく、その先の推移的依存関係まで含めた管理が求められます

### [サプライチェーンの障害（OWASP A03）](#supply-chain-failure-owasp) {#supply-chain-failure-owasp}

[06-application-security](../06-application-security/) で学んだ OWASP Top 10 の A03「Software Supply Chain Failures」は、この問題を含むサプライチェーン全体の障害を扱っています

> Software supply chain failures are breakdowns or other compromises in the process of building, distributing, or updating software.

> ソフトウェアサプライチェーンの障害とは、ソフトウェアの構築、配布、または更新のプロセスにおける破綻や侵害である

問題は悪意あるパッケージだけではありません

既知の脆弱性を持つパッケージが更新されないまま使い続けられることも、大きなリスクです

メンテナンスが停止したライブラリは、新たな脆弱性が発見されても修正されないため、時間の経過とともにリスクが増大します

---

## [メンテナの信頼とソースコードの改ざん](#maintainer-trust-and-tampering) {#maintainer-trust-and-tampering}

### [メンテナという信頼モデル](#maintainer-trust-model) {#maintainer-trust-model}

オープンソースソフトウェアは、メンテナへの信頼に依存しています

メンテナはリポジトリへの書き込み権限を持ち、新しいバージョンを公開できます

この信頼モデルは、[03-certificate](../03-certificate/) で学んだ PKI における認証局（CA）への信頼と構造的に似ています

CA は証明書を発行する権限を持ち、その CA が信頼できることを前提に証明書の検証が成り立ちます

メンテナも同様に、コードを公開する権限を持ち、そのメンテナが信頼できることを前提にソフトウェアの安全性が成り立ちます

ただし、PKI には証明書の検証プロセスや Certificate Transparency のような監視の仕組みがあります

一方、オープンソースのメンテナへの信頼は、多くの場合、非公式で検証の仕組みが限られています

### [xz-utils バックドア：メンテナの信頼が悪用された事例](#xz-utils-backdoor-case) {#xz-utils-backdoor-case}

2024 年に発見された xz-utils バックドア（CVE-2024-3094）は、メンテナの信頼が悪用された事例です

[03-certificate](../03-certificate/) では、信頼されていた存在が悪用されるという構造がソフトウェアのサプライチェーンにも共通すると述べました

xz-utils バックドアはまさにその具体例です

この事件では、新しいコントリビューターが約 2 年かけて xz-utils プロジェクトの信頼を獲得しました

正当な貢献を続けることでコメンテナの地位を得た後、ビルドスクリプトに難読化された悪意あるコードを挿入しました

```
  xz-utils バックドアの流れ：

  新しいコントリビューター
       │
       │ 約 2 年かけて正当な貢献で信頼を構築
       ▼
  コメンテナの地位を獲得
       │
       │ ビルドスクリプトに難読化コードを挿入
       ▼
  悪意あるコードがビルド成果物に混入
       │
       │ sshd → systemd → liblzma（xz-utils）
       ▼
  SSH 認証がバイパスされる
```

注目すべき点がいくつかあります

まず、悪意あるコードはソースコードに直接挿入されたのではなく、<strong>ビルドスクリプト</strong>に挿入されました

ソースコードをレビューしても、バックドアを発見することは困難でした

次に、発見は偶然でした

ある開発者が SSH 接続の異常なパフォーマンス低下に気づき、調査した結果、バックドアが発覚しました

最後に、この事件は [03-certificate](../03-certificate/) で学んだ DigiNotar 事件と同じ構造を持っています

DigiNotar では信頼された CA が侵害され、xz-utils では信頼されたメンテナが悪用されました

どちらも「信頼された存在の悪用」という共通のパターンです

### [ソーシャルエンジニアリングとメンテナの疲弊](#social-engineering-and-maintainer-burnout) {#social-engineering-and-maintainer-burnout}

xz-utils バックドアは、技術的な攻撃であると同時に、ソーシャルエンジニアリングの攻撃でもありました

攻撃者は、既存のメンテナに対してメンテナンスの引き渡しを促す圧力をかけました

オープンソースプロジェクトの多くは、少数のボランティアによってメンテナンスされています

メンテナの疲弊や燃え尽きは、攻撃者がプロジェクトに介入する隙を生みます

これは技術的な脆弱性ではなく、オープンソースのエコシステムが持つ<strong>構造的な脆弱性</strong>です

重要なインフラストラクチャがボランティアのメンテナに依存している場合、そのメンテナへの信頼が唯一の防御線となります

---

## [パッケージレジストリへの攻撃](#package-registry-attacks) {#package-registry-attacks}

### [npm サプライチェーン攻撃](#npm-supply-chain-attack) {#npm-supply-chain-attack}

npm（Node.js のパッケージレジストリ）のエコシステムでは、複数のサプライチェーン攻撃が発生しています

代表的な事例が event-stream 事件です

event-stream は人気のある npm パッケージでしたが、メンテナが多忙のためメンテナンスを新しい開発者に引き渡しました

新しいメンテナは、flatmap-stream という悪意ある依存関係を追加し、特定の暗号通貨ウォレットアプリケーションを標的にしました

```
  event-stream 事件の構造：

  多数のアプリケーション
       │
       └── event-stream（人気パッケージ）
             │
             │ メンテナンスの引き渡し
             ▼
       新しいメンテナが悪意ある依存を追加
             │
             └── flatmap-stream（悪意あるパッケージ）
                   │
                   ▼
             特定のウォレットアプリを標的に攻撃
```

この攻撃は、xz-utils バックドアと共通する構造を持っています

どちらも「信頼されたメンテナの地位が悪用される」というパターンですが、event-stream では既存メンテナからの引き渡しで地位を得たのに対し、xz-utils では約 2 年かけて信頼を自ら構築した点が異なります

### [タイポスクワッティング](#typosquatting) {#typosquatting}

<strong>タイポスクワッティング</strong>（Typosquatting）は、人気パッケージに似た名前の悪意あるパッケージを登録する攻撃手法です

たとえば、`lodash` の代わりに `loadsh` や `l0dash` のようなパッケージを登録します

開発者がパッケージ名を打ち間違えると、悪意あるパッケージがインストールされます

この攻撃は、パッケージ名を信頼してインストールするという仕組み自体を悪用しています

技術的な脆弱性ではなく、人間のタイプミスを狙った攻撃です

### [依存関係の混同（Dependency Confusion）](#dependency-confusion) {#dependency-confusion}

<strong>依存関係の混同</strong>（Dependency Confusion）は、パッケージマネージャが内部パッケージと外部パッケージを解決する仕組みを悪用する攻撃です

企業が内部で使用するプライベートパッケージ（たとえば `company-utils`）と同じ名前のパッケージを、公開レジストリにより高いバージョン番号で登録します

パッケージマネージャがバージョンの高い公開パッケージを優先する場合、内部パッケージの代わりに悪意あるパッケージがインストールされます

```
  依存関係の混同：

  社内レジストリ                  公開レジストリ（npm）
  company-utils@1.0.0             company-utils@99.0.0（悪意あるパッケージ）
       │                                │
       └── パッケージマネージャ ──────────┘
                  │
                  ▼
           バージョンが高い公開パッケージを優先
```

### [レジストリ自体の脆弱性](#registry-vulnerability) {#registry-vulnerability}

パッケージレジストリのインフラストラクチャ自体も攻撃対象です

レジストリの認証トークンが漏洩すると、正規のパッケージが悪意あるバージョンに置き換えられる可能性があります

これはサプライチェーンの「配布」段階への攻撃であり、ソースコードやビルドが安全であっても、配布の段階で改ざんが発生する可能性を示しています

---

## [ビルドの完全性](#build-integrity) {#build-integrity}

### [ソースコードとビルド成果物のギャップ](#source-code-build-artifact-gap) {#source-code-build-artifact-gap}

ソースコードリポジトリで公開されているコードと、実際に配布されるパッケージ（ビルド成果物）は、同一であるとは限りません

ビルドプロセスは、ソースコードを実行可能な形式に変換します

この変換の過程で改ざんが行われた場合、ソースコードをレビューしても問題を発見できません

xz-utils バックドアはまさにこのギャップを悪用しました

悪意あるコードはソースコードではなく<strong>ビルドスクリプト</strong>に挿入されたため、ソースコードのレビューだけでは検出できませんでした

### [ビルドシステムへの攻撃](#build-system-attacks) {#build-system-attacks}

CI/CD（継続的インテグレーション / 継続的デリバリー）のビルドシステムは、高い価値を持つ攻撃対象です

ビルドシステムが侵害されると、そのシステムを使うすべてのプロジェクトの成果物が影響を受けます

```
  ビルドシステムへの攻撃：

  ソースコード           ビルドシステム          成果物
  （安全）          →    （侵害）          →    （危険）

  同じソースコードから
  異なる成果物が生成される可能性がある
```

ビルド環境からの秘密情報（署名鍵、認証トークン）の漏洩も、ビルドシステムへの攻撃の一形態です

### [再現可能なビルド](#reproducible-builds) {#reproducible-builds}

<strong>再現可能なビルド</strong>（Reproducible Build）とは、同じソースコードと同じビルド環境から、ビット単位で同一の成果物を生成できるビルド手法です

再現可能なビルドが実現されていれば、誰でも独立にビルドを再実行し、配布されている成果物と比較検証できます

もし結果が異なれば、ビルドの過程で何らかの改ざんが行われたことを意味します

この検証は、[01-cryptography](../01-cryptography/) で学んだハッシュ関数の応用です

ビルド成果物のハッシュ値を比較することで、改ざんの有無を確認できます

再現可能なビルドが実現されていない場合、配布されている成果物がソースコードから正当に生成されたものかどうかを検証する方法がありません

---

## [ソフトウェア署名と検証](#software-signing) {#software-signing}

### [なぜ署名が必要か](#why-signing) {#why-signing}

[01-cryptography](../01-cryptography/) で学んだデジタル署名と、[03-certificate](../03-certificate/) で学んだ PKI の知識を振り返りましょう

デジタル署名は「誰が作成したか」と「改ざんされていないか」を暗号的に検証する仕組みでした

ソフトウェア署名はこの原理をソフトウェア成果物に適用したものです

署名がなければ、レジストリが改ざんされていないこと、ネットワーク上で成果物がすり替えられていないことを信頼するしかありません

署名があれば、これらの信頼を暗号的に<strong>検証</strong>できます

### [従来のソフトウェア署名の課題](#traditional-signing-challenges) {#traditional-signing-challenges}

従来のソフトウェア署名には、いくつかの課題がありました

まず、長期間有効な署名鍵の管理が必要です

署名鍵が漏洩すれば、その鍵で署名されたすべての成果物の信頼が失われます

次に、鍵の配布の問題です

検証者が署名を確認するためには、署名者の公開鍵を信頼できる方法で入手する必要があります

これらの課題は、特にオープンソースのメンテナにとって大きな負担でした

鍵の安全な管理は専門知識を要し、ボランティアのメンテナに過度な責任を求めることになります

### [Sigstore：ソフトウェア署名のオープンスタンダード](#sigstore) {#sigstore}

Sigstore は、ソフトウェア署名の課題を解決するために設計されたオープンスタンダードです

Sigstore の核心は、<strong>キーレス署名</strong>（Keyless Signing）です

開発者は長期間有効な署名鍵を管理する必要がなく、身元認証に基づく短期証明書を使って署名します

Sigstore は 3 つのコンポーネントで構成されています

<strong>Fulcio（認証局）</strong>

Fulcio は短期署名証明書を発行する認証局です

[03-certificate](../03-certificate/) で学んだ CA と同じ役割ですが、発行する証明書は短期間（数分）のみ有効です

開発者は OIDC（OpenID Connect）トークンで身元を証明し、Fulcio がその身元に紐づく短期証明書を発行します

<strong>Rekor（透明性ログ）</strong>

Rekor は署名の記録を不変のログに保存する透明性ログです

[03-certificate](../03-certificate/) で学んだ Certificate Transparency と同じ原理です

Certificate Transparency がすべての証明書の発行を公開ログに記録するように、Rekor はすべてのソフトウェア署名を公開ログに記録します

これにより、不正な署名を検出できるようになります

<strong>Cosign（署名ツール）</strong>

Cosign はコンテナイメージやソフトウェア成果物に署名・検証を行うツールです

```
  Sigstore の署名フロー：

  開発者
    │ OIDC 認証（メールアドレスや CI のワークフロー情報）
    ▼
  Fulcio（短期証明書の発行）
    │ 身元に紐づく短期証明書を発行
    ▼
  成果物に署名（一時的な鍵ペアで署名後、秘密鍵を破棄）
    │
    ▼
  Rekor（透明性ログに記録）
    │ 署名、成果物のダイジェスト、証明書を記録
    ▼
  検証者が署名と透明性ログを検証
```

Sigstore の設計は、[03-certificate](../03-certificate/) で学んだ概念の直接的な応用です

Fulcio は CA、Rekor は Certificate Transparency、そして全体の仕組みは PKI の原理に基づいています

従来の署名との最大の違いは、開発者が長期的な鍵を管理する必要がないことです

身元認証に基づく短期証明書を使うことで、鍵の漏洩リスクを大幅に低減しています

---

## [SLSA フレームワーク](#slsa) {#slsa}

### [SLSA とは](#what-is-slsa) {#what-is-slsa}

<strong>SLSA</strong>（Supply-chain Levels for Software Artifacts、「サルサ」と読む）は、ソフトウェアサプライチェーンのセキュリティを段階的に高めるためのフレームワークです

> SLSA is a set of incrementally adoptable guidelines for supply chain security, established by industry consensus.

> SLSA は、業界の合意に基づいて策定された、段階的に導入可能なサプライチェーンセキュリティのガイドラインである

SLSA は特定のツールではなく、サプライチェーンの信頼性をレベルごとに定義した要件の集合です

段階的に導入できるため、すべてを一度に実現する必要はありません

### [SLSA のレベル](#slsa-levels) {#slsa-levels}

SLSA はビルドトラック（Build Track）として、L0 から L3 のレベルを定義しています

{: .labeled}
| レベル | 要件 | 保証される信頼性 |
| -------------------------- | ------------------------------------------------------------------------ | ---------------------------------- |
| Build L0（基準なし） | 要件なし | セキュリティの保証なし |
| Build L1（来歴あり） | ビルドプロセスが文書化されている、来歴情報が生成される | ソフトウェアの出所が記録されている |
| Build L2（ビルドサービス） | ホストされたビルドサービスを使用、来歴情報が署名されている | ビルド後の改ざんが検出できる |
| Build L3（隔離あり） | 隔離されたビルド環境、ビルド間の相互影響がない、秘密情報へのアクセス制限 | ビルド中の改ざんが困難 |

レベルが上がるほど、より強力な保護が提供されますが、実装の労力も大きくなります

```
  SLSA レベルの保護範囲：

  Build L0 ─── 保証なし（開発やテスト用のビルド）

  Build L1 ─── 来歴情報がある（誰がいつ何からビルドしたか）
                ただし署名されておらず、偽造が容易

  Build L2 ─── 署名された来歴情報 ＋ ホストされたビルド
                ビルド後の改ざんを検出できる

  Build L3 ─── 隔離されたビルド ＋ 改ざん耐性のある来歴情報
                ビルド中の改ざん（内部犯、認証情報の侵害）が困難
```

### [来歴情報（Provenance）](#provenance) {#provenance}

<strong>来歴情報</strong>（Provenance）とは、ソフトウェア成果物がどのように生成されたかを記述するメタデータです

来歴情報は以下の問いに答えます

- どのソースコードからビルドされたか
- どのビルドシステムが使用されたか
- どのビルドパラメータが使用されたか

これは「日常の例え」で紹介した食品のトレーサビリティと同じ発想です

食品のトレーサビリティが「どの農園で栽培され、どの工場で加工され、どの経路で配送されたか」を記録するように、来歴情報は「どのソースコードから、どのビルドシステムで、どのように生成されたか」を記録します

来歴情報がソフトウェア署名で保護されていれば、その記録自体の改ざんも検出できます

### [SLSA と OWASP A08](#slsa-and-owasp) {#slsa-and-owasp}

SLSA フレームワークは、OWASP Top 10 の A08「Software or Data Integrity Failures」に直接対応しています

> Software and data integrity failures relate to code and infrastructure that does not protect against invalid or untrusted code or data being treated as trusted and valid.

> ソフトウェアとデータの完全性の障害は、無効または信頼できないコードやデータが信頼され有効なものとして扱われることを防げないコードやインフラストラクチャに関連する

A08 は具体的に以下のリスクを挙げています

- 署名なしの更新メカニズム
- CI/CD パイプラインの完全性の欠如
- 信頼できないソースからのライブラリの使用

SLSA はこれらのリスクに対して、ビルドの完全性と来歴情報という仕組みで対応しています

---

## [コンテナイメージの信頼](#container-image-trust) {#container-image-trust}

### [コンテナイメージのサプライチェーン](#container-image-supply-chain) {#container-image-supply-chain}

コンテナイメージは、サプライチェーンの具体的な例です

1 つのコンテナイメージには、ベース OS のレイヤ、アプリケーションの依存関係、アプリケーションコードが含まれています

それぞれのレイヤは異なるソースから来ています

ベース OS はコンテナレジストリから、依存関係はパッケージマネージャから、アプリケーションコードはソースリポジトリから取得されます

コンテナの学習で学んだイメージのレイヤ構造を思い出してください

各レイヤが信頼できるソースから取得され、改ざんされていないことを確認する必要があります

### [イメージの署名と検証](#image-signing-and-verification) {#image-signing-and-verification}

コンテナイメージは Sigstore の Cosign を使って署名できます

署名により、「誰がこのイメージをビルドしたか」「ビルド後に改ざんされていないか」を検証できます

イメージの識別には<strong>イメージダイジェスト</strong>が使用されます

イメージダイジェストは、[01-cryptography](../01-cryptography/) で学んだハッシュ関数で計算される値であり、イメージの内容を一意に識別します

タグ（たとえば `nginx:latest`）は可変であり、同じタグが異なるイメージを指すことがあります

一方、ダイジェスト（たとえば `nginx@sha256:abc123...`）はイメージの内容から計算されるため、不変です

イメージの検証にはタグではなく、ダイジェストを使用するのが原則です

### [オーケストレーションへの橋渡し](#container-image-bridge-to-orchestration) {#container-image-bridge-to-orchestration}

コンテナイメージの信頼は、オーケストレーション環境でさらに重要になります

多数のコンテナが自動的にデプロイされる環境では、イメージ署名の検証も自動化される必要があります

手動での検証は、数百のコンテナが稼働する環境では現実的ではありません

オーケストレーションの学習では、コンテナイメージの信頼性がシステム全体のセキュリティにどのように影響するかを、より詳しく学びます

---

## [OWASP Top 10 との対応](#owasp-top-10-correspondence) {#owasp-top-10-correspondence}

[06-application-security](../06-application-security/) で学んだ OWASP Top 10 のうち、A03 と A08 がサプライチェーンセキュリティに対応しています

OWASP Top 10:2025 では、サプライチェーンセキュリティが独立カテゴリ（A03）として設けられ、2021 版の A06「Vulnerable and Outdated Components」から範囲が拡大されました

{: .labeled}
| OWASP カテゴリ | 対応する脅威 | このトピックでの対応セクション |
| --------------------------------------- | ---------------------------------------------------------------------- | -------------------------------------- |
| A03 Software Supply Chain Failures | 既知の脆弱性を持つ依存関係、ビルドパイプラインの侵害、悪意ある依存関係 | 依存関係の信頼と推移的依存関係 |
| A08 Software or Data Integrity Failures | CI/CD パイプラインの改ざん、署名なしの更新 | ビルドの完全性、ソフトウェア署名、SLSA |

A03 は「何に依存しているか」の問題です

依存関係の可視化、推移的依存の把握、脆弱なコンポーネントの検出と更新が対策です

A08 は「依存先が改ざんされていないか」の問題です

ソフトウェア署名、来歴情報、再現可能なビルドにより、成果物の完全性を検証することが対策です

---

## [防御レイヤの全体像：01 から 07 まで](#defense-layer-overview) {#defense-layer-overview}

### [01 から 07 までの統合](#all-chapters-integration) {#all-chapters-integration}

このリポジトリで学んだ防御レイヤの全体像を整理します

```
  防御レイヤの全体像：

  ┌────────────────────────────────────────────┐
  │ サプライチェーンの防御（07）                  │
  │ 依存関係の検証、署名、ビルドの完全性          │
  ├────────────────────────────────────────────┤
  │ アプリケーションの防御（06）                  │
  │ 入力検証、出力エンコーディング、              │
  │ セキュリティヘッダ、CSRF トークン             │
  ├────────────────────────────────────────────┤
  │ アクセス制御の防御（05）                      │
  │ RBAC、最小権限、デフォルト拒否                │
  ├────────────────────────────────────────────┤
  │ 認証の防御（04）                              │
  │ パスワードハッシュ、MFA、セッション管理        │
  ├────────────────────────────────────────────┤
  │ 証明書と PKI の防御（03）                     │
  │ サーバー認証、信頼の連鎖                      │
  ├────────────────────────────────────────────┤
  │ TLS の防御（02）                              │
  │ 通信路の暗号化、前方秘匿性                    │
  ├────────────────────────────────────────────┤
  │ 暗号化の防御（01）                            │
  │ 機密性、完全性、真正性                        │
  └────────────────────────────────────────────┘
```

各レイヤが異なる脅威を防御し、1 つのレイヤが突破されても他のレイヤが防御を継続します

{: .labeled}
| レイヤ | 防御対象 | このレイヤが破られた場合 |
| ---------------------- | -------------------------------- | ---------------------------- |
| 暗号化（01） | データの機密性と完全性 | 他のレイヤで検知・防御 |
| TLS（02） | 通信路の盗聴と中間者攻撃 | 認証とアクセス制御が防御 |
| 証明書（03） | サーバーの偽装 | ブラウザの警告で検知 |
| 認証（04） | なりすまし | アクセス制御が防御 |
| アクセス制御（05） | 権限外の操作 | 入力検証が防御 |
| アプリケーション（06） | 悪意ある入力 | 多層防御で被害を限定 |
| サプライチェーン（07） | 信頼されたコンポーネントの改ざん | 署名検証、来歴情報、多層防御 |

これが 01 から 07 までの<strong>多層防御</strong>の全体像です

セキュリティは「完璧な 1 つの防御」ではなく、「不完全でも複数の防御を重ねること」で実現されます

---

## [まとめ：このリポジトリで学んだこと](#repository-learning-summary) {#repository-learning-summary}

このリポジトリでは、「システムはどう安全に保たれるか」を学びました

### [学んだトピック](#learned-topics) {#learned-topics}

{: .labeled}
| トピック | 内容 |
| ----------------------- | ------------------------------------------------------------------------------------------------ |
| 01-cryptography | 対称暗号、非対称暗号、ハッシュ関数が情報の機密性・完全性・真正性を保護する |
| 02-tls | TLS が暗号化、認証、完全性の 3 つの方法で通信路を保護し、前方秘匿性で過去の通信も守る |
| 03-certificate | 証明書と PKI が信頼の連鎖でサーバーの身元を保証し、Certificate Transparency で不正発行を検出する |
| 04-authentication | 認証がユーザーの身元を確認し、セッション・JWT・OAuth でログイン状態と権限委譲を管理する |
| 05-access-control | アクセス制御モデル（DAC、MAC、RBAC、ABAC）が「誰が何をできるか」を体系的に管理する |
| 06-application-security | 「入力を信頼しない」の原則でインジェクション攻撃を防ぎ、多層防御で複数の防御層を重ねる |
| 07-supply-chain | 依存関係の検証、ソフトウェア署名、ビルドの完全性でサプライチェーン全体の信頼を確保する |

### [すべてがつながる：1 つの HTTP リクエストの旅](#http-request-journey) {#http-request-journey}

ここで、1 つの HTTP リクエストが処理される過程を通じて、7 つのトピックがどうつながるかを見てみましょう

<strong>01-cryptography：暗号化</strong>

リクエストの本文は AES-GCM で暗号化され、サーバーの身元はデジタル署名で検証されます

暗号化がデータの機密性と完全性を保護する基盤です

<strong>02-tls：TLS</strong>

TLS ハンドシェイクが一時的な鍵で安全な通信路を確立します

前方秘匿性により、仮にサーバーの秘密鍵が漏洩しても、過去の通信は保護されます

<strong>03-certificate：証明書と PKI</strong>

サーバーの証明書が PKI の信頼の連鎖を通じて検証されます

ルート CA まで辿ることで、接続先が正当なサーバーであることを確認します

<strong>04-authentication：認証</strong>

ユーザーが提示する JWT トークンが署名鍵で検証されます

認証により、リクエストの送信者が正当なユーザーであることを確認します

<strong>05-access-control：アクセス制御</strong>

ユーザーの役割が RBAC ポリシーと照合され、リクエストされた操作が許可されているかを確認します

最小権限の原則により、必要最小限の権限のみが付与されています

<strong>06-application-security：アプリケーションセキュリティ</strong>

リクエストのパラメータが入力検証を通過し、レスポンスは出力エンコーディングで安全に返されます

多層防御により、1 つの防御が破られても他の防御が機能します

<strong>07-supply-chain：サプライチェーンセキュリティ</strong>

このリクエストを処理するアプリケーション自体、その依存関係、そしてアプリケーションが稼働するコンテナイメージは、すべて署名され、来歴情報が検証された状態でデプロイされています

01 から 06 までの防御が機能するためには、そもそもソフトウェア自体が信頼できるものでなければなりません

このように、1 つの HTTP リクエストが安全に処理されるために、7 つのトピックで学んだすべての仕組みが連携して動いています

### [オーケストレーションへの橋渡し](#summary-bridge-to-orchestration) {#summary-bridge-to-orchestration}

このリポジトリでは、セキュリティの各要素がなぜ必要で、どう機能するかを学びました

暗号化、TLS、証明書、認証、アクセス制御、アプリケーションセキュリティ、サプライチェーンセキュリティの知識は、コンテナ群が協調して動くオーケストレーション環境で横断的に必要になります

オーケストレーションの学習では、秘密情報の管理（04 の認証）、ネットワークポリシー（02 の TLS と 05 のアクセス制御）、コンテナイメージの信頼（07 のサプライチェーン）が重要な前提知識となります

セキュリティの原理を理解した状態で、コンテナ群の協調の仕組みを学ぶ準備が整いました

---

## [用語集](#glossary) {#glossary}

{: .labeled}
| 用語 | 説明 |
| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| サプライチェーンセキュリティ（Supply Chain Security） | ソフトウェアの開発、ビルド、配布の全過程における信頼性を確保するためのセキュリティ対策の総称 |
| ソフトウェアサプライチェーン | ソースコードから依存関係の解決、ビルド、配布、デプロイまでの一連の流れ |
| 直接依存（Direct Dependency） | アプリケーションが明示的に宣言する外部ライブラリ |
| 推移的依存（Transitive Dependency） | 直接依存が内部で使用する依存関係。依存の連鎖を形成する |
| Log4Shell（CVE-2021-44228） | Apache Log4j ライブラリの脆弱性。推移的依存関係により広範囲に影響した事例 |
| xz-utils バックドア（CVE-2024-3094） | 信頼されたメンテナの地位を悪用して挿入されたバックドア。メンテナの信頼の問題を顕在化させた事例 |
| タイポスクワッティング（Typosquatting） | 人気パッケージに似た名前の悪意あるパッケージを登録する攻撃手法 |
| 依存関係の混同（Dependency Confusion） | パッケージマネージャが内部パッケージと同名の外部パッケージを優先する仕組みを悪用する攻撃手法 |
| 再現可能なビルド（Reproducible Build） | 同じソースコードとビルド環境から、ビット単位で同一の成果物を生成できるビルド手法。ビルド成果物の検証を可能にする |
| 来歴情報（Provenance） | ソフトウェア成果物がどのように生成されたかを記述するメタデータ。ソースコード、ビルドシステム、パラメータなどの情報を含む |
| ソフトウェア署名（Software Signing） | 暗号的な署名により、成果物の出所と改ざんの有無を検証可能にする仕組み |
| キーレス署名（Keyless Signing） | 長期的な署名鍵を使わず、身元認証に基づく短期証明書で署名する方式。Sigstore が採用している |
| Sigstore | ソフトウェア署名のオープンスタンダード。キーレス署名により、鍵管理の負担なしにソフトウェア成果物の署名と検証を実現する |
| Cosign | Sigstore のコンポーネント。コンテナイメージやソフトウェア成果物に署名・検証を行う |
| Fulcio | Sigstore の認証局。OIDC 認証に基づく短期署名証明書を発行する |
| Rekor | Sigstore の透明性ログ。署名の記録を不変のログに保存し、不正な署名の検出を可能にする |
| SLSA（Supply-chain Levels for Software Artifacts） | ソフトウェアサプライチェーンのセキュリティを段階的に高めるためのフレームワーク |
| SLSA Build Level | SLSA が定義するビルドプロセスの信頼性のレベル。L0（基準なし）から L3（隔離されたビルド）まで |
| ビルドの完全性（Build Integrity） | ソースコードからビルド成果物が改ざんなく生成されたことの保証 |
| パッケージレジストリ（Package Registry） | ソフトウェアパッケージを保存・配布するサービス。npm、PyPI、Maven Central など |
| イメージダイジェスト（Image Digest） | コンテナイメージの内容からハッシュ関数で計算される値。イメージの一意な識別に使用される |
| CI/CD（継続的インテグレーション / 継続的デリバリー） | コードの統合、テスト、ビルド、デプロイを自動化するプラクティス。ビルドパイプラインの信頼性がサプライチェーンセキュリティに直結する |
| OWASP A03（Software Supply Chain Failures） | OWASP Top 10 のカテゴリ。ソフトウェアサプライチェーンの障害によるリスク |
| OWASP A08（Software or Data Integrity Failures） | OWASP Top 10 のカテゴリ。ソフトウェアまたはデータの完全性の障害によるリスク |
| ソーシャルエンジニアリング（Social Engineering） | 技術的な攻撃ではなく、人間の心理や信頼関係を悪用する攻撃手法 |

---

## [参考資料](#references) {#references}

このページの内容は、以下のソースに基づいています

<strong>サプライチェーンフレームワーク</strong>

- [SLSA - Supply-chain Levels for Software Artifacts](https://slsa.dev/){:target="\_blank"}
  - ソフトウェアサプライチェーンのセキュリティフレームワーク
- [Sigstore](https://sigstore.dev/){:target="\_blank"}
  - ソフトウェア署名のオープンスタンダード

<strong>OWASP</strong>

- [OWASP Top 10 (2025) - A03 Software Supply Chain Failures](https://owasp.org/Top10/2025/A03_2025-Software_Supply_Chain_Failures/){:target="\_blank"}
  - ソフトウェアサプライチェーンの障害の分類とガイドライン
- [OWASP Top 10 (2025) - A08 Software or Data Integrity Failures](https://owasp.org/Top10/2025/A08_2025-Software_or_Data_Integrity_Failures/){:target="\_blank"}
  - ソフトウェアまたはデータの完全性の障害の分類とガイドライン

<strong>事例</strong>

- [CVE-2021-44228 - Apache Log4j](https://www.cve.org/CVERecord?id=CVE-2021-44228){:target="\_blank"}
  - Log4Shell 脆弱性の CVE レコード
- [CVE-2024-3094 - xz-utils](https://www.cve.org/CVERecord?id=CVE-2024-3094){:target="\_blank"}
  - xz-utils バックドアの CVE レコード

<strong>再現可能なビルド</strong>

- [Reproducible Builds](https://reproducible-builds.org/){:target="\_blank"}
  - 再現可能なビルドの取り組みとドキュメント
