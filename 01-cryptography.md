---
layout: default
title: 暗号化の基礎
---

# [01-cryptography：暗号化の基礎](#cryptography) {#cryptography}

## [はじめに](#introduction) {#introduction}

前のシリーズでは、TLS が通信を暗号化・認証・完全性の 3 つの方法で保護することを学びました

TLS ハンドシェイクで鍵を共有し、暗号スイートで通信を暗号化する、という流れを学びました

しかし、「暗号化」の中身についてはまだ深く触れていません

公開鍵で暗号化したデータを秘密鍵でのみ復号できるのはなぜでしょうか？

鍵共有パラメータの交換だけで、なぜ安全な共通鍵を作れるのでしょうか？

暗号化と改ざん検出を同時に行う AEAD とは、具体的にどのような仕組みでしょうか？

このトピックでは、暗号化の基礎として、対称暗号、非対称暗号、ハッシュ関数、そして鍵交換の原理を学びます

数学的な証明は扱いませんが、「なぜ安全か」の直感的な理解を目指します

---

## [日常の例え](#everyday-analogy) {#everyday-analogy}

暗号化の基本的な仕組みを、日常の例えで見てみましょう

<strong>対称暗号 = 同じ鍵の南京錠</strong>

あなたと友人が、同じ鍵で開閉できる南京錠を持っているとします

あなたは箱に手紙を入れ、南京錠で施錠して送ります

友人は同じ鍵で南京錠を開け、手紙を読みます

この方法は<strong>速くて効率的</strong>ですが、最初に鍵をどうやって安全に渡すかという問題があります

<strong>非対称暗号 = 誰でも入れられるポスト</strong>

友人の家の前に、誰でも手紙を投函できるポストがあるとします

ポストの投入口は開いていますが、取り出すための鍵は友人だけが持っています

誰でも手紙を入れられますが、読めるのは友人だけです

投入口が<strong>公開鍵</strong>、取り出す鍵が<strong>秘密鍵</strong>に対応します

<strong>ハッシュ関数 = 指紋</strong>

人間の指紋は、その人固有のものです

書類に指紋を押すと、その書類が本人によるものだと確認できます

また、書類の内容を少しでも変えれば、押された指紋との整合性が崩れます

ハッシュ関数はデータの「指紋」を作り、データが<strong>改ざんされていないこと</strong>を確認する仕組みです

<strong>鍵交換 = 色の混合</strong>

あなたと友人が、同じ色を作りたいとします

2 人は公開の場で共通の色（たとえば黄色）を決めます

あなたは黄色に自分だけの秘密の色（たとえば赤）を混ぜ、友人に渡します

友人は黄色に自分だけの秘密の色（たとえば青）を混ぜ、あなたに渡します

あなたは受け取った色に赤を混ぜ、友人は受け取った色に青を混ぜると、2 人とも<strong>同じ最終色</strong>にたどり着きます

しかし、途中の混合色を見ただけでは、元の秘密の色を分離することは非常に困難です

これが<strong>Diffie-Hellman 鍵交換</strong>の直感的な仕組みです

---

## [このページで学ぶこと](#what-you-will-learn) {#what-you-will-learn}

このページでは、以下の概念を学びます

<strong>暗号化の必要性</strong>

- <strong>なぜ暗号化が必要か</strong>
  - 盗聴、改ざん、なりすましの脅威
- <strong>暗号化の 3 つの柱</strong>
  - 機密性、完全性、真正性

<strong>対称暗号</strong>

- <strong>対称暗号の仕組み</strong>
  - 同じ鍵で暗号化と復号を行う方式
- <strong>代表的なアルゴリズム</strong>
  - AES、ChaCha20

<strong>非対称暗号（公開鍵暗号）</strong>

- <strong>公開鍵と秘密鍵</strong>
  - RSA、楕円曲線暗号の直感的な理解
- <strong>デジタル署名</strong>
  - 秘密鍵による署名と公開鍵による検証

<strong>ハッシュ関数</strong>

- <strong>ハッシュ関数の性質</strong>
  - 一方向性、衝突耐性、雪崩効果
- <strong>ハッシュ関数の用途</strong>
  - データ完全性の検証、パスワード保存

<strong>鍵交換</strong>

- <strong>Diffie-Hellman 鍵交換</strong>
  - 安全でない通信路で共通鍵を作る仕組み
- <strong>エフェメラル鍵と前方秘匿性</strong>
  - セッションごとに使い捨てる鍵の考え方

---

## [目次](#table-of-contents) {#table-of-contents}

1. [なぜ暗号化が必要か](#why-encryption)
2. [暗号化の全体像](#cryptography-overview)
3. [対称暗号](#symmetric-cryptography)
4. [非対称暗号（公開鍵暗号）](#asymmetric-cryptography)
5. [ハッシュ関数](#hash-function)
6. [Diffie-Hellman 鍵交換](#diffie-hellman-key-exchange)
7. [AEAD（暗号化と改ざん検出の同時実行）](#aead)
8. [暗号化の組み合わせ](#cryptography-combination)
9. [次のトピックへ](#next-topic)
10. [用語集](#glossary)
11. [参考資料](#references)

---

## [なぜ暗号化が必要か](#why-encryption) {#why-encryption}

インターネット上の通信は、何も対策をしなければ<strong>平文</strong>（暗号化されていないデータ）で流れます

平文の通信には、3 つの脅威があります

### [盗聴（Eavesdropping）](#eavesdropping) {#eavesdropping}

通信経路上の第三者が、流れるデータを読み取ることです

たとえば、カフェの公衆 Wi-Fi に接続してオンラインバンキングにログインする場面を考えましょう

通信が暗号化されていなければ、同じネットワーク上の攻撃者がログイン情報を傍受できる可能性があります

### [改ざん（Tampering）](#tampering) {#tampering}

通信経路上の第三者が、流れるデータを書き換えることです

たとえば、ソフトウェアのダウンロード中に、攻撃者がファイルの一部をマルウェアに差し替える可能性があります

受信者は、受け取ったデータが送信者の意図通りかどうか確認する手段がありません

### [なりすまし（Impersonation）](#impersonation) {#impersonation}

第三者が、正規の通信相手のふりをすることです

たとえば、攻撃者が銀行のサイトに見せかけた偽サイトを作り、ユーザーの認証情報を窃取する可能性があります

ユーザーは、通信相手が本物の銀行かどうか確認する手段がありません

### [中間者攻撃（Man-in-the-Middle Attack）](#man-in-the-middle-attack) {#man-in-the-middle-attack}

中間者攻撃は、上記の 3 つの脅威をすべて組み合わせた攻撃手法です

攻撃者が通信経路の中間に位置し、双方に対して相手のふりをします

```
  通常の通信：
  ┌────────┐                              ┌────────┐
  │ Alice  │─────────── 通信 ──────────→│  Bob   │
  └────────┘                              └────────┘

  中間者攻撃：
  ┌────────┐          ┌────────┐          ┌────────┐
  │ Alice  │── 通信 →│ 攻撃者 │── 通信 →│  Bob   │
  └────────┘          └────────┘          └────────┘
                      盗聴・改ざん・
                      なりすまし
```

Alice は Bob と通信していると思っていますが、実際には攻撃者と通信しています

攻撃者は Alice からのデータを<strong>盗聴</strong>し、必要に応じて<strong>改ざん</strong>し、Bob に転送します

Bob も攻撃者を Alice だと思っています

この攻撃を防ぐには、盗聴・改ざん・なりすましのすべてに対策が必要です

暗号化の技術は、これらの脅威に対する解決策を提供します

---

## [暗号化の全体像](#cryptography-overview) {#cryptography-overview}

暗号化の技術は、3 つの脅威に対応する 3 つの柱で構成されています

{: .labeled}
| 脅威 | 対策 | 使用する技術 |
| ---------- | ------------------------------------- | -------------------- |
| 盗聴 | <strong>機密性</strong>（暗号化） | 対称暗号、非対称暗号 |
| 改ざん | <strong>完全性</strong>（改ざん検出） | ハッシュ関数、AEAD |
| なりすまし | <strong>真正性</strong>（認証） | デジタル署名、証明書 |

<strong>機密性</strong>（Confidentiality）とは、許可された人だけがデータを読めることです

対称暗号や非対称暗号を使って、データを暗号化します

<strong>完全性</strong>（Integrity）とは、データが改ざんされていないことを確認できることです

ハッシュ関数や AEAD を使って、データの改ざんを検出します

<strong>真正性</strong>（Authenticity）とは、通信相手が本人であることを確認できることです

デジタル署名や証明書を使って、相手の身元を検証します

TLS は、これらの技術をすべて組み合わせて通信を保護しています

以降のセクションでは、各技術の仕組みを個別に学んでいきます

---

## [対称暗号](#symmetric-cryptography) {#symmetric-cryptography}

### [対称暗号とは](#what-is-symmetric-cryptography) {#what-is-symmetric-cryptography}

<strong>対称暗号</strong>（Symmetric Encryption）は、暗号化と復号に<strong>同じ鍵</strong>を使う方式です

```
  暗号化：
  ┌──────┐     ┌─────┐     ┌──────┐
  │ 平文 │──→│  鍵  │──→│ 暗号文 │
  └──────┘     └─────┘     └──────┘

  復号：
  ┌──────┐     ┌─────┐     ┌──────┐
  │ 暗号文│──→│ 同じ鍵│──→│ 平文 │
  └──────┘     └─────┘     └──────┘
```

送信者が鍵を使って平文を暗号文に変換し、受信者が同じ鍵を使って暗号文を平文に戻します

「対称」と呼ばれるのは、暗号化と復号で<strong>同じ鍵</strong>を使うためです

### [代表的な対称暗号アルゴリズム](#symmetric-cryptography-algorithms) {#symmetric-cryptography-algorithms}

{: .labeled}
| アルゴリズム | 種類 | 特徴 |
| ------------ | -------------- | ------------------------------------------------------------------- |
| AES | ブロック暗号 | NIST が公開コンペで選定した標準。128 / 192 / 256 ビットの鍵長に対応 |
| ChaCha20 | ストリーム暗号 | ハードウェアによる AES 高速化が使えない環境向けに設計 |

<strong>AES</strong>（Advanced Encryption Standard）は、最も広く使われている対称暗号アルゴリズムです

2001 年に NIST が世界中から候補を募り、安全性と効率性を評価する公開コンペで選定しました

<strong>ChaCha20</strong> は、ハードウェアによる AES の高速化機能を持たない環境（一部のモバイル端末など）で使われるアルゴリズムです

### [ブロック暗号とストリーム暗号](#block-and-stream-cipher) {#block-and-stream-cipher}

対称暗号には 2 つの種類があります

<strong>ブロック暗号</strong>は、データを固定長のブロック（AES の場合は 128 ビット）に分割し、ブロックごとに暗号化します

<strong>ストリーム暗号</strong>は、鍵から擬似乱数のストリーム（鍵ストリーム）を生成し、データと 1 バイトずつ組み合わせて暗号化します

どちらの種類も、暗号化と復号で同じ鍵を使う点は共通しています

### [対称暗号の特徴](#symmetric-cryptography-characteristics) {#symmetric-cryptography-characteristics}

対称暗号の最大の利点は<strong>処理速度</strong>です

後述する非対称暗号と比較して、同じデータ量の暗号化・復号が高速に行えます

そのため、大量のデータを暗号化する用途（通信データの暗号化など）では対称暗号が使われます

### [鍵配送問題](#key-distribution-problem) {#key-distribution-problem}

対称暗号には根本的な課題があります

暗号化と復号に同じ鍵を使うため、通信相手と<strong>事前に鍵を共有</strong>する必要があります

直接会って鍵を渡せるなら問題ありませんが、インターネット上の相手とはそれができません

暗号化されていない通信路で鍵を送れば、第三者に鍵を盗まれる可能性があります

これを<strong>鍵配送問題</strong>（Key Distribution Problem）といいます

この問題は、後述する非対称暗号や Diffie-Hellman 鍵交換によって解決されます

---

## [非対称暗号（公開鍵暗号）](#asymmetric-cryptography) {#asymmetric-cryptography}

### [非対称暗号とは](#what-is-asymmetric-cryptography) {#what-is-asymmetric-cryptography}

<strong>非対称暗号</strong>（Asymmetric Encryption）は、<strong>公開鍵</strong>と<strong>秘密鍵</strong>という 2 つの異なる鍵を使う方式です

<strong>公開鍵暗号</strong>（Public Key Cryptography）とも呼ばれます

```
  暗号化：
  ┌──────┐     ┌──────┐     ┌──────┐
  │ 平文 │──→│ 公開鍵│──→│ 暗号文 │
  └──────┘     └──────┘     └──────┘

  復号：
  ┌──────┐     ┌──────┐     ┌──────┐
  │ 暗号文│──→│ 秘密鍵│──→│ 平文 │
  └──────┘     └──────┘     └──────┘
```

公開鍵は誰にでも配布でき、秘密鍵は所有者だけが保持します

公開鍵で暗号化したデータは、対応する秘密鍵でのみ復号できます

これにより、鍵配送問題が解決されます

送信者は受信者の公開鍵（誰でも入手可能）で暗号化すれば、受信者だけが秘密鍵で復号できるためです

### [公開鍵と秘密鍵](#public-and-private-key) {#public-and-private-key}

公開鍵と秘密鍵は<strong>鍵ペア</strong>として生成されます

この 2 つの鍵は数学的に関連していますが、一方からもう一方を求めることは非常に困難です

{: .labeled}
| 鍵 | 配布 | 用途 |
| ------ | ------------ | ------------------ |
| 公開鍵 | 自由に配布 | 暗号化、署名の検証 |
| 秘密鍵 | 本人のみ保持 | 復号、署名の作成 |

公開鍵を知っていても秘密鍵を求められないことが、非対称暗号の安全性の基盤です

### [RSA](#rsa) {#rsa}

<strong>RSA</strong> は、最も広く知られている非対称暗号アルゴリズムです

1977 年に Rivest、Shamir、Adleman の 3 人が発表しました

RSA の安全性は、<strong>大きな数の素因数分解が困難</strong>であることに基づいています

2 つの大きな素数を掛け合わせるのは簡単です

しかし、その積（非常に大きな数）を元の 2 つの素数に分解することは、現在のコンピュータでは非常に長い時間がかかります

この「掛け算は簡単だが、逆の分解は困難」という性質が、RSA の安全性を支えています

### [楕円曲線暗号（ECC）](#ecc) {#ecc}

<strong>楕円曲線暗号</strong>（Elliptic Curve Cryptography）は、楕円曲線上の数学的な性質に基づく非対称暗号です

ECC の安全性は、<strong>楕円曲線上の離散対数問題が困難</strong>であることに基づいています

RSA と比較した場合の最大の利点は、<strong>短い鍵長で同等の安全性</strong>を達成できることです

NIST SP 800-57 による鍵長の比較を示します

{: .labeled}
| セキュリティ強度 | RSA 鍵長 | ECC 鍵長 |
| ---------------- | ------------ | ---------- |
| 112 ビット | 2048 ビット | 224 ビット |
| 128 ビット | 3072 ビット | 256 ビット |
| 192 ビット | 7680 ビット | 384 ビット |
| 256 ビット | 15360 ビット | 512 ビット |

セキュリティ強度とは、その暗号を解読するために必要な計算量を表す指標です

128 ビットのセキュリティ強度を得るために、RSA は 3072 ビットの鍵が必要ですが、ECC は 256 ビットで済みます

鍵長が短いため、計算速度が速く、通信データ量も少なくなります

TLS 1.3 では、鍵交換に楕円曲線ベースの方式（ECDHE）が広く使われています

### [デジタル署名](#digital-signature) {#digital-signature}

非対称暗号は暗号化だけでなく、<strong>デジタル署名</strong>にも使われます

デジタル署名は、暗号化とは逆の方向で鍵を使います

{: .labeled}
| 操作 | 使用する鍵 | 目的 |
| ------ | ---------- | ------------------------------------------------ |
| 暗号化 | 公開鍵 | データの機密性を保護する |
| 復号 | 秘密鍵 | 暗号化されたデータを元に戻す |
| 署名 | 秘密鍵 | データの作成者と改ざんされていないことを証明する |
| 検証 | 公開鍵 | 署名が正しいことを確認する |

署名の流れは以下のとおりです

1. 送信者がデータのハッシュ値（後述）を計算する
2. 送信者が自分の<strong>秘密鍵</strong>でハッシュ値に署名する
3. 受信者が送信者の<strong>公開鍵</strong>で署名を検証する

署名が正しければ、以下の 2 つが確認できます

- <strong>真正性</strong>：データは秘密鍵の所有者が作成した（秘密鍵を持つ人しか署名を作れないため）
- <strong>完全性</strong>：データは改ざんされていない（データが変わればハッシュ値が変わり、署名の検証が失敗するため）

デジタル署名の仕組みは、証明書（[03-certificate](../03-certificate/)）の基盤となります

### [非対称暗号の特徴](#asymmetric-cryptography-characteristics) {#asymmetric-cryptography-characteristics}

非対称暗号は鍵配送問題を解決しますが、<strong>処理速度が遅い</strong>という特徴があります

対称暗号と比較して、暗号化・復号に多くの計算量が必要です

そのため、大量のデータの暗号化には向きません

実際の通信では、非対称暗号は<strong>鍵の交換や署名</strong>に使い、データの暗号化には<strong>対称暗号</strong>を使う、という組み合わせが一般的です

---

## [ハッシュ関数](#hash-function) {#hash-function}

### [ハッシュ関数とは](#what-is-hash-function) {#what-is-hash-function}

<strong>ハッシュ関数</strong>（Hash Function）は、任意の長さのデータを入力として、固定長の値を出力する関数です

出力された値を<strong>ハッシュ値</strong>（ダイジェスト）といいます

```
  入力（任意の長さ）           ハッシュ関数          出力（固定長）
  ┌─────────────────┐     ┌──────────┐     ┌──────────────┐
  │ Hello, World!   │──→│  SHA-256  │──→│ 315f5bdb...  │
  └─────────────────┘     └──────────┘     └──────────────┘

  ┌─────────────────┐     ┌──────────┐     ┌──────────────┐
  │ Hello, World!!  │──→│  SHA-256  │──→│ a16bdf8...   │
  └─────────────────┘     └──────────┘     └──────────────┘
```

入力が 1 文字違うだけで、ハッシュ値はまったく異なります

暗号化との違いは、ハッシュ関数は<strong>一方向</strong>であることです

暗号化はデータを元に戻せますが、ハッシュ関数は元に戻せません

### [ハッシュ関数の 3 つの性質](#hash-function-three-properties) {#hash-function-three-properties}

暗号学的ハッシュ関数は、以下の 3 つの性質を満たします

{: .labeled}
| 性質 | 意味 |
| ------------------------------------------------- | ----------------------------------------------------------- |
| <strong>一方向性</strong>（Pre-image Resistance） | ハッシュ値から元のデータを求めることが困難 |
| <strong>衝突耐性</strong>（Collision Resistance） | 同じハッシュ値を持つ 2 つの異なるデータを見つけることが困難 |
| <strong>雪崩効果</strong>（Avalanche Effect） | 入力のわずかな変化で、出力が大きく変わる |

<strong>一方向性</strong>があるため、ハッシュ値を知っていても元のデータを復元できません

<strong>衝突耐性</strong>があるため、偽のデータで同じハッシュ値を作ることが困難です

<strong>雪崩効果</strong>があるため、データのわずかな変更でもハッシュ値が大きく変わり、改ざんの検出に使えます

### [代表的なハッシュ関数](#major-hash-functions) {#major-hash-functions}

{: .labeled}
| アルゴリズム | 出力長 | 状態 |
| ------------ | ---------- | ------------------------------------------------ |
| SHA-256 | 256 ビット | NIST 標準（SHA-2 ファミリ）、広く使用されている |
| SHA-384 | 384 ビット | NIST 標準（SHA-2 ファミリ）、より高い安全性 |
| SHA-3 | 可変 | NIST 標準、SHA-2 とは異なる設計の次世代ハッシュ |
| MD5 | 128 ビット | 衝突が発見されており、セキュリティ用途では非推奨 |
| SHA-1 | 160 ビット | 衝突が発見されており、セキュリティ用途では非推奨 |

<strong>SHA-256</strong> と <strong>SHA-384</strong> は、SHA-2（Secure Hash Algorithm 2）ファミリに属するハッシュ関数で、NIST によって標準化されています

TLS 1.3 の暗号スイートでは、SHA-256 または SHA-384 が使われています

MD5 と SHA-1 は、衝突が発見された（同じハッシュ値を持つ異なるデータが見つかった）ため、セキュリティ用途では使うべきではありません

### [ハッシュ関数の用途](#hash-function-use-cases) {#hash-function-use-cases}

ハッシュ関数は、暗号化の多くの場面で使われています

<strong>データ完全性の検証</strong>

ファイルをダウンロードする際、配布元がハッシュ値を公開していることがあります

ダウンロードしたファイルのハッシュ値を計算し、公開されたハッシュ値と比較することで、ファイルが改ざんされていないことを確認できます

<strong>デジタル署名</strong>

デジタル署名では、データ全体に署名するのではなく、データのハッシュ値に署名します

ハッシュ値は固定長で短いため、署名処理を効率的に行えます

<strong>パスワード保存</strong>

パスワードを平文で保存するのは危険です

代わりに、パスワードのハッシュ値を保存します

ログイン時には、入力されたパスワードのハッシュ値と保存されたハッシュ値を比較します

ハッシュ関数の一方向性により、保存されたハッシュ値からパスワードを復元できません

パスワード保存の詳細は [04-authentication](../04-authentication/) で学びます

<strong>HMAC（Hash-based Message Authentication Code）</strong>

ハッシュ関数と秘密鍵を組み合わせた認証コードです

データの完全性に加えて、送信者が鍵を持っていることも確認できます

---

## [Diffie-Hellman 鍵交換](#diffie-hellman-key-exchange) {#diffie-hellman-key-exchange}

### [鍵配送問題の解決](#key-distribution-solution) {#key-distribution-solution}

対称暗号のセクションで、鍵配送問題を学びました

非対称暗号はこの問題を解決する方法の 1 つですが、処理が遅いため大量のデータの暗号化には向きません

<strong>Diffie-Hellman 鍵交換</strong>は、別のアプローチでこの問題を解決します

安全でない通信路を通じて、双方が<strong>同じ共有秘密</strong>（共通鍵の元になる値）を作り出します

### [Diffie-Hellman 鍵交換の仕組み](#diffie-hellman-mechanism) {#diffie-hellman-mechanism}

日常の例えで紹介した「色の混合」の仕組みを、もう少し具体的に見てみましょう

```
  Alice                    公開の通信路                    Bob

  1. 公開パラメータを合意する（大きな素数 p と生成元 g）
     ←──────────── p, g ────────────→

  2. 各自が秘密の値を選ぶ
     秘密の値 a を選ぶ                         秘密の値 b を選ぶ

  3. 公開値を計算する
     A = g^a mod p                             B = g^b mod p

  4. 公開値を交換する
     ─────────────── A ────────────→
     ←──────────── B ────────────────

  5. 共有秘密を計算する
     s = B^a mod p                             s = A^b mod p
     = g^(ab) mod p                            = g^(ab) mod p

     両者とも同じ値 s にたどり着く
```

攻撃者は通信路上で p、g、A、B を見ることができますが、秘密の値 a や b を知らなければ共有秘密 s を計算できません

A から a を求めるには、<strong>離散対数問題</strong>を解く必要がありますが、p が十分に大きければこれは非常に困難です

### [なぜ安全か](#why-secure) {#why-secure}

Diffie-Hellman 鍵交換の安全性は、<strong>離散対数問題の困難さ</strong>に基づいています

`g^a mod p` の計算は簡単に行えます（べき乗剰余の計算は効率的なアルゴリズムがあります）

しかし、`g^a mod p` の結果と g、p を知っていても、a を逆算することは非常に困難です

これは RSA の「掛け算は簡単だが因数分解は困難」と同じ構造です

ある方向の計算は簡単だが、逆方向の計算は困難、という<strong>一方向関数</strong>の性質が安全性を支えています

### [エフェメラル鍵と前方秘匿性](#ephemeral-key-and-forward-secrecy) {#ephemeral-key-and-forward-secrecy}

ここまでの説明では、Alice と Bob の秘密の値（a と b）は固定でした

しかし、もし秘密の値が何らかの理由で漏洩した場合、過去のすべての通信が解読されてしまいます

この問題を解決するのが<strong>エフェメラル鍵</strong>（Ephemeral Key、一時鍵）です

エフェメラル鍵とは、<strong>通信セッションごとに新しく生成し、使い終わったら破棄する</strong>鍵のことです

毎回新しい秘密の値を使うため、ある 1 つのセッションの鍵が漏洩しても、他のセッションの通信は安全なままです

この性質を<strong>前方秘匿性</strong>（Forward Secrecy）といいます

前方秘匿性があれば、長期的な秘密鍵が将来漏洩しても、過去の通信記録は解読できません

前方秘匿性がプロトコル上でどのように実現されているかは、[02-tls](../02-tls/) で詳しく学びます

### [楕円曲線 Diffie-Hellman（ECDHE）](#ecdhe) {#ecdhe}

<strong>ECDHE</strong>（Elliptic Curve Diffie-Hellman Ephemeral）は、楕円曲線上の離散対数問題を利用した Diffie-Hellman 鍵交換です

楕円曲線暗号と同様に、通常の Diffie-Hellman より<strong>短いパラメータで同等の安全性</strong>を達成できます

末尾の「E」は Ephemeral を意味し、前方秘匿性が組み込まれています

TLS 1.3 では、鍵交換方式として ECDHE が標準的に使われています

---

## [AEAD（暗号化と改ざん検出の同時実行）](#aead) {#aead}

### [なぜ暗号化だけでは不十分か](#why-encryption-alone-insufficient) {#why-encryption-alone-insufficient}

対称暗号でデータを暗号化すれば、盗聴は防げます

しかし、暗号化だけでは<strong>改ざんを検出できません</strong>

たとえば、攻撃者が暗号文の一部のビットを反転させた場合を考えましょう

受信者が復号すると、元のデータとは異なる結果が得られますが、それが改ざんによるものか、元のデータがそうだったのか判断できません

暗号化（機密性）に加えて、改ざん検出（完全性）も同時に必要です

### [AEAD とは](#what-is-aead) {#what-is-aead}

<strong>AEAD</strong>（Authenticated Encryption with Associated Data）は、暗号化と改ざん検出を<strong>1 つの操作で同時に</strong>行う方式です

```
  暗号化（AEAD）：
  ┌──────┐
  │ 平文 │──┐
  └──────┘  │     ┌──────┐     ┌──────┐  ┌──────────┐
            ├──→│  鍵   │──→│ 暗号文 │  │ 認証タグ │
  ┌──────┐  │     └──────┘     └──────┘  └──────────┘
  │ AAD  │──┘
  └──────┘

  復号（AEAD）：
  ┌──────┐  ┌──────────┐
  │ 暗号文│  │ 認証タグ │──┐
  └──────┘  └──────────┘  │     ┌──────┐     検証成功 → 平文
            ├──────────────┤──→│  鍵   │──→
  ┌──────┐  │              │     └──────┘     検証失敗 → 破棄
  │ AAD  │──┘
  └──────┘
```

暗号化時に、平文を暗号化するとともに<strong>認証タグ</strong>（Authentication Tag）を生成します

復号時に、まず認証タグを検証し、検証が成功した場合のみ復号を行います

認証タグの検証が失敗した場合、データは改ざんされたものとして<strong>破棄</strong>されます

### [Associated Data（関連データ）](#associated-data) {#associated-data}

AEAD の「AD」は Associated Data（関連データ）を指します

<strong>AAD</strong>（Additional Authenticated Data）とも呼ばれます

AAD は<strong>暗号化はされないが、改ざん検出の対象にはなる</strong>データです

たとえば、TLS では通信レコードのヘッダが AAD に該当します

ヘッダには通信のメタ情報（プロトコルバージョンやデータ長など）が含まれており、これらは読める必要がありますが、改ざんは防ぐ必要があります

### [代表的な AEAD アルゴリズム](#major-aead-algorithms) {#major-aead-algorithms}

{: .labeled}
| アルゴリズム | 構成 | 特徴 |
| ----------------- | ------------------------------------ | ----------------------------------------- |
| AES-GCM | AES（暗号化）+ GHASH（認証） | TLS 1.3 で最も広く使われている |
| ChaCha20-Poly1305 | ChaCha20（暗号化）+ Poly1305（認証） | ハードウェア AES 高速化が使えない環境向け |

<strong>AES-GCM</strong>（AES in Galois/Counter Mode）は、AES による暗号化と GHASH による認証を組み合わせた方式です

<strong>ChaCha20-Poly1305</strong> は、ChaCha20 による暗号化と Poly1305 による認証を組み合わせた方式です

どちらも、暗号化と改ざん検出を 1 つの操作で効率的に行います

TLS 1.3 では、すべての暗号スイートが AEAD を採用しています

---

## [暗号化の組み合わせ](#cryptography-combination) {#cryptography-combination}

ここまで学んだ暗号化の要素が、実際にどう組み合わされるかを見てみましょう

TLS 1.3 の暗号スイートの 1 つに `TLS_AES_256_GCM_SHA384` があります

この名前を分解すると、このトピックで学んだ要素が含まれています

{: .labeled}
| 部分 | カテゴリ | このトピックで学んだこと |
| ------- | ------------ | ------------------------------ |
| AES_256 | 対称暗号 | データの暗号化（256 ビット鍵） |
| GCM | AEAD モード | 暗号化と改ざん検出の同時実行 |
| SHA384 | ハッシュ関数 | ハンドシェイクの完全性確認 |

この暗号スイートは、以下のように各要素を組み合わせて使います

<strong>鍵交換</strong>

ECDHE を使って、クライアントとサーバーが共有秘密を作ります

エフェメラル鍵を使うため、前方秘匿性が確保されます

<strong>データの暗号化</strong>

共有秘密から導出した鍵を使い、AES-256-GCM（AEAD）で通信データを暗号化します

暗号化と改ざん検出が同時に行われます

<strong>サーバーの認証</strong>

サーバーは自身の秘密鍵でデジタル署名を作成し、クライアントがサーバーの公開鍵（証明書に含まれる）で検証します

<strong>完全性の確認</strong>

ハンドシェイク全体の完全性を SHA-384 のハッシュで確認します

このように、対称暗号、非対称暗号、ハッシュ関数、鍵交換、AEAD は、それぞれ単独で使われるのではなく、<strong>組み合わせて</strong>使われることで安全な通信を実現しています

TLS がこれらをどのように組み合わせているかの詳細は、次のトピックで学びます

---

## [次のトピックへ](#next-topic) {#next-topic}

このトピックでは、以下のことを学びました

- 暗号化は、盗聴・改ざん・なりすましの 3 つの脅威に対応する機密性・完全性・真正性の 3 つの柱で構成されている
- 対称暗号は同じ鍵で暗号化・復号を行い、高速だが鍵配送問題がある
- 非対称暗号は公開鍵と秘密鍵のペアを使い、鍵配送問題を解決するが処理が遅い
- ハッシュ関数は一方向性・衝突耐性・雪崩効果の性質を持ち、データの完全性検証に使われる
- Diffie-Hellman 鍵交換は、安全でない通信路で共有秘密を作り出す仕組みであり、エフェメラル鍵を使うことで前方秘匿性を実現する
- AEAD は暗号化と改ざん検出を同時に行い、TLS 1.3 ではすべての暗号スイートが AEAD を採用している

しかし、ここで大きな疑問が残っています

これらの暗号化技術は、具体的にどう組み合わされて通信を安全にしているのでしょうか？

TLS ハンドシェイクでは、なぜ 1 往復で安全な鍵を共有できるのでしょうか？

前方秘匿性は、プロトコル上でどのように実現されているのでしょうか？

0-RTT（最初の通信で即座にデータを送る仕組み）にはどのようなリスクがあるのでしょうか？

次のトピック [02-tls](../02-tls/) では、これらの暗号化技術を組み合わせた<strong>TLS の原理</strong>を学びます

---

## [用語集](#glossary) {#glossary}

{: .labeled}
| 用語 | 説明 |
| -------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| 暗号化（Encryption） | データを第三者に読めない形式に変換すること |
| 復号（Decryption） | 暗号化されたデータを元の形式に戻すこと |
| 平文（Plaintext） | 暗号化されていない、そのまま読めるデータ |
| 暗号文（Ciphertext） | 暗号化されたデータ |
| 対称暗号（Symmetric Encryption） | 暗号化と復号に同じ鍵を使う暗号方式 |
| 非対称暗号（Asymmetric Encryption） | 暗号化と復号に異なる鍵（公開鍵と秘密鍵）を使う暗号方式。公開鍵暗号とも呼ばれる |
| 公開鍵（Public Key） | 鍵ペアの一方で、自由に配布できる鍵。暗号化や署名の検証に使う |
| 秘密鍵（Private Key） | 鍵ペアの一方で、所有者のみが保持する鍵。復号や署名の作成に使う |
| 鍵ペア | 公開鍵と秘密鍵の組み合わせ。数学的に関連しているが、一方から他方を求めることは困難 |
| RSA | 大きな数の素因数分解の困難さに基づく非対称暗号アルゴリズム。1977 年に Rivest、Shamir、Adleman が発表 |
| 楕円曲線暗号（ECC） | 楕円曲線上の離散対数問題の困難さに基づく非対称暗号。RSA より短い鍵長で同等の安全性を達成する |
| ハッシュ関数（Hash Function） | 任意の長さのデータから固定長の値（ハッシュ値）を計算する一方向関数 |
| ハッシュ値（ダイジェスト） | ハッシュ関数の出力。データの「指紋」のようなもの |
| SHA-256 / SHA-384 | NIST が標準化した SHA-2 ファミリのハッシュ関数。それぞれ 256 ビット / 384 ビットの出力を持つ |
| 一方向性（Pre-image Resistance） | ハッシュ値から元のデータを求めることが困難である性質 |
| 衝突耐性（Collision Resistance） | 同じハッシュ値を持つ異なる 2 つのデータを見つけることが困難である性質 |
| 雪崩効果（Avalanche Effect） | 入力のわずかな変化でハッシュ値が大きく変わる性質 |
| デジタル署名 | 秘密鍵でデータに署名し、公開鍵で検証する仕組み。データの真正性と完全性を確認できる |
| Diffie-Hellman 鍵交換 | 安全でない通信路を通じて、2 者が同じ共有秘密を作り出す鍵交換プロトコル |
| ECDHE | Elliptic Curve Diffie-Hellman Ephemeral の略。楕円曲線を使った一時鍵による Diffie-Hellman 鍵交換 |
| エフェメラル鍵（Ephemeral Key） | 通信セッションごとに生成し、使い終わったら破棄する一時的な鍵 |
| 前方秘匿性（Forward Secrecy） | 長期的な鍵が漏洩しても、過去の通信が解読されない性質。エフェメラル鍵の使用で実現する |
| 鍵配送問題（Key Distribution Problem） | 対称暗号で、通信相手と安全に鍵を共有する方法がないという問題 |
| AEAD | Authenticated Encryption with Associated Data の略。暗号化と改ざん検出を 1 つの操作で同時に行う方式 |
| AES | Advanced Encryption Standard の略。NIST が公開コンペで選定した対称暗号の標準アルゴリズム |
| AES-GCM | AES を Galois/Counter Mode で使用する AEAD 方式。TLS 1.3 で最も広く使われている |
| ChaCha20-Poly1305 | ChaCha20（ストリーム暗号）と Poly1305（認証）を組み合わせた AEAD 方式 |
| 認証タグ（Authentication Tag） | AEAD が生成する値で、データの改ざんを検出するために使われる |
| AAD（Additional Authenticated Data） | AEAD で暗号化はされないが、改ざん検出の対象となるデータ |
| ブロック暗号 | データを固定長のブロックに分割し、ブロックごとに暗号化する方式。AES が代表例 |
| ストリーム暗号 | 鍵から擬似乱数のストリームを生成し、データと組み合わせて暗号化する方式。ChaCha20 が代表例 |
| 暗号スイート（Cipher Suite） | TLS で使用する暗号アルゴリズムの組み合わせ。鍵交換、暗号化、ハッシュの各アルゴリズムを指定する |
| HMAC | Hash-based Message Authentication Code の略。ハッシュ関数と秘密鍵を組み合わせた認証コード |
| 機密性（Confidentiality） | 許可された人だけがデータを読める状態を保証する性質 |
| 完全性（Integrity） | データが改ざんされていないことを確認できる性質 |
| 真正性（Authenticity） | 通信相手が本人であること、データの作成者が本人であることを確認できる性質 |
| 盗聴（Eavesdropping） | 通信経路上の第三者が、流れるデータを不正に読み取ること |
| 中間者攻撃（Man-in-the-Middle Attack） | 攻撃者が通信の中間に位置し、双方に対して相手のふりをして通信を傍受・改ざんする攻撃 |
| 離散対数問題 | `g^a mod p` の結果から a を求める計算問題。Diffie-Hellman 鍵交換と楕円曲線暗号の安全性の基盤 |

---

## [参考資料](#references) {#references}

このページの内容は、以下のソースに基づいています

<strong>暗号化標準</strong>

- [NIST SP 800-175B Rev. 1 - Guideline for Using Cryptographic Standards](https://csrc.nist.gov/pubs/sp/800/175/b/r1/final){:target="\_blank"}
  - 暗号化標準の使用ガイドライン（対称暗号、非対称暗号、ハッシュ関数の分類と推奨）

- [NIST SP 800-57 Part 1 Rev. 5 - Recommendation for Key Management](https://csrc.nist.gov/pubs/sp/800/57/pt1/r5/final){:target="\_blank"}
  - 鍵管理の推奨事項（鍵長の比較、セキュリティ強度の定義）

<strong>TLS プロトコル</strong>

- [RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3](https://datatracker.ietf.org/doc/html/rfc8446){:target="\_blank"}
  - TLS 1.3 の仕様（暗号スイートの定義、AEAD の要件、鍵交換方式）

<strong>ハッシュ関数</strong>

- [NIST FIPS 180-4 - Secure Hash Standard (SHS)](https://csrc.nist.gov/pubs/fips/180-4/upd1/final){:target="\_blank"}
  - SHA-2 ファミリ（SHA-256、SHA-384 等）の仕様

<strong>デジタル署名</strong>

- [NIST FIPS 186-5 - Digital Signature Standard (DSS)](https://csrc.nist.gov/pubs/fips/186-5/final){:target="\_blank"}
  - RSA、ECDSA 等のデジタル署名アルゴリズムの仕様
