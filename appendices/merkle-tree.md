---
layout: default
title: マークル木はどうやって改ざんを検出するのか
---

# [マークル木はどうやって改ざんを検出するのか](#merkle-tree) {#merkle-tree}

## [はじめに](#introduction) {#introduction}

[03-certificate](../../03-certificate/) では、Certificate Transparency（CT）のログ構造として<strong>マークル木</strong>が登場しました

03-certificate では、マークル木を「[01-cryptography](../../01-cryptography/) で学んだハッシュ関数の応用で、大量の証明書を効率的に管理し、特定の証明書がログに含まれていることを少ないデータ量で証明できます」と紹介しました

しかし、具体的にどうやって「少ないデータ量で証明できる」のかは説明しませんでした

また、[07-supply-chain](../../07-supply-chain/) で学んだ Sigstore の Rekor（透明性ログ）も同じデータ構造を使っています

この補足資料では、マークル木の構造と、なぜ少ないデータ量で「特定のデータがログに含まれること」を証明できるのかを学びます

---

## [このページで学ぶこと](#what-you-will-learn) {#what-you-will-learn}

- マークル木がどのような構造を持つか
- 包含証明（Inclusion Proof）がなぜ効率的に機能するか
- Certificate Transparency と Sigstore でマークル木がどう使われているか

---

## [目次](#table-of-contents) {#table-of-contents}

1. [ハッシュリストの限界](#hash-list-limitations)
2. [マークル木の構造](#merkle-tree-structure)
3. [ルートハッシュの意味](#root-hash-meaning)
4. [包含証明（Inclusion Proof）](#inclusion-proof)
5. [Certificate Transparency での応用](#certificate-transparency-application)
6. [Sigstore での応用](#sigstore-application)
7. [まとめ](#summary)
8. [用語集](#glossary)
9. [参考資料](#references)

---

## [ハッシュリストの限界](#hash-list-limitations) {#hash-list-limitations}

01-cryptography で学んだとおり、ハッシュ関数はデータの完全性（改ざんされていないこと）を検証するために使います

複数のデータの完全性を検証する単純な方法は、各データのハッシュ値をリストとして保存することです

```
データ A → H(A)
データ B → H(B)
データ C → H(C)
データ D → H(D)
```

「データ B がリストに含まれること」を証明するには、リスト全体を渡して検証者に確認してもらう必要があります

データが 100 万件あれば、100 万個のハッシュ値を渡す必要があります

これは<strong>リストのサイズに比例して検証コストが増大する</strong>問題です

マークル木は、この問題を解決するデータ構造です

---

## [マークル木の構造](#merkle-tree-structure) {#merkle-tree-structure}

<strong>マークル木</strong>（Merkle tree）は、1979 年に暗号学者 <strong>Ralph Merkle</strong> が発明した、ハッシュ値を木構造で組み合わせるデータ構造です

4 つのデータ（A、B、C、D）がある場合、マークル木は以下のように構築されます

<strong>ステップ 1：リーフノードの作成</strong>

各データのハッシュ値を計算し、木の<strong>リーフ（葉）ノード</strong>とします

```
H(A)    H(B)    H(C)    H(D)
```

<strong>ステップ 2：中間ノードの作成</strong>

隣接する 2 つのハッシュ値を結合し、その結合データのハッシュ値を計算して<strong>中間ノード</strong>とします

```
H(A) と H(B) を結合 → H(H(A) + H(B)) = HAB
H(C) と H(D) を結合 → H(H(C) + H(D)) = HCD
```

<strong>ステップ 3：ルートノードの作成</strong>

中間ノードの結合を繰り返し、最終的に 1 つの<strong>ルートハッシュ</strong>にたどり着きます

```
HAB と HCD を結合 → H(HAB + HCD) = ルートハッシュ
```

全体の構造は以下のようになります

```
              [ルートハッシュ]
             /              \
          [HAB]            [HCD]
         /     \          /     \
      [H(A)] [H(B)]   [H(C)] [H(D)]
        |      |        |      |
        A      B        C      D
```

---

## [ルートハッシュの意味](#root-hash-meaning) {#root-hash-meaning}

ルートハッシュは、木に含まれる<strong>全てのデータの要約</strong>です

01-cryptography で学んだハッシュ関数の<strong>雪崩効果</strong>（入力が 1 ビットでも変わると出力が大きく変わる）により、木の中のどのデータが 1 バイトでも変更されれば、ルートハッシュは全く異なる値になります

たとえば、データ C が改ざんされた場合を考えてみましょう

```
H(C) が変わる → HCD が変わる → ルートハッシュが変わる
```

つまり、ルートハッシュを 1 つ保持するだけで、木の中の全データの完全性を保証できます

---

## [包含証明（Inclusion Proof）](#inclusion-proof) {#inclusion-proof}

### [仕組み](#mechanism) {#mechanism}

包含証明は、<strong>特定のデータが木に含まれていること</strong>を、木全体を渡さずに証明する仕組みです

「データ B が木に含まれていること」を証明したい場合、検証者が必要とするのは以下の情報だけです

1. データ B 自体（またはそのハッシュ値 H(B)）
2. H(B) からルートハッシュまでの<strong>経路上の兄弟ノード</strong>のハッシュ値
3. ルートハッシュ（信頼済み）

具体的には、以下のハッシュ値を提供します

```
              [ルートハッシュ] ← 信頼済み
             /              \
          [HAB]            [HCD] ← 提供（2）
         /     \
      [H(A)] [H(B)]
        |      |
   提供（1）   B ← 証明対象
```

検証者は以下の手順で検証します

1. H(B) を計算する
2. 提供された H(A) と H(B) を結合して HAB を計算する
3. 計算した HAB と提供された HCD を結合してルートハッシュを計算する
4. 計算したルートハッシュが信頼済みのルートハッシュと一致するか確認する

### [効率性](#efficiency) {#efficiency}

包含証明に必要なハッシュ値の数は、<strong>木の高さ</strong>に等しくなります

木の高さはデータ数の対数（log2）であるため、データが増えても必要なハッシュ値の数は緩やかにしか増えません

{: .labeled}
| データ数 | ハッシュリストで必要な値 | マークル木で必要な値（包含証明） |
| ---------------------- | ------------------------ | -------------------------------- |
| 8 | 8 | 3 |
| 1,024 | 1,024 | 10 |
| 1,048,576（約 100 万） | 1,048,576 | 20 |
| 10 億 | 10 億 | 30 |

10 億件のデータの中から 1 件の包含を証明するのに、わずか <strong>30 個のハッシュ値</strong>で済みます

これが、マークル木が大規模なログシステムに適している理由です

---

## [Certificate Transparency での応用](#certificate-transparency-application) {#certificate-transparency-application}

03-certificate で学んだ Certificate Transparency（CT）は、認証局が発行した全ての証明書を<strong>公開ログ</strong>に記録する仕組みです

CT ログはマークル木を使って証明書を管理しています

### [CT ログの仕組み](#ct-log-mechanism) {#ct-log-mechanism}

CT ログに証明書が追加されると、その証明書はマークル木のリーフノードとなります

CT ログサーバーは、証明書が正式にログに記録されたことを証明するために <strong>SCT</strong>（Signed Certificate Timestamp）を発行します

ブラウザや監査者が「特定の証明書がログに含まれていること」を確認したい場合、CT ログサーバーに包含証明を要求します

CT ログサーバーは、ルートハッシュまでの経路上の兄弟ノードのハッシュ値を返します

検証者はこれらのハッシュ値を使ってルートハッシュを再計算し、署名されたルートハッシュと一致するかを確認します

### [なぜ CT にマークル木が適しているか](#why-merkle-tree-for-ct) {#why-merkle-tree-for-ct}

CT ログには数億の証明書が記録されています

ハッシュリスト方式では、1 つの証明書の存在を確認するために数億個のハッシュ値が必要ですが、マークル木の包含証明なら約 30 個のハッシュ値で済みます

また、CT ログには証明書が<strong>追加されるのみ</strong>（削除や変更がない）という特性があります

マークル木は追加専用の操作と相性が良く、新しい証明書が追加されるたびに木が成長しますが、既存のハッシュ値は変わりません

---

## [Sigstore での応用](#sigstore-application) {#sigstore-application}

07-supply-chain で学んだ Sigstore の <strong>Rekor</strong> も、マークル木を使った透明性ログです

Rekor は、ソフトウェアの署名記録を公開ログに記録します

CT ログと同じ原理で、以下が実現されています

{: .labeled}
| 機能 | マークル木の役割 |
| -------------- | ------------------------------------------------------------ |
| 署名記録の追加 | 新しい署名記録をリーフノードとして追加 |
| 存在の証明 | 包含証明で、特定の署名記録がログに含まれることを効率的に証明 |
| 改ざんの検出 | ルートハッシュの変化で、過去の記録の改ざんを検出 |

CT ログが「証明書の透明性」を実現するように、Rekor は「ソフトウェア署名の透明性」を実現しています

両者に共通する設計思想は、<strong>追加専用の公開ログをマークル木で管理し、包含証明で効率的な検証を可能にする</strong>ことです

---

## [まとめ](#summary) {#summary}

{: .labeled}
| ポイント | 説明 |
| -------------------------------------------- | ----------------------------------------------- |
| ハッシュリストは非効率 | データ数に比例して検証コストが増加する |
| マークル木はハッシュ値を木構造で組み合わせる | リーフ → 中間ノード → ルートハッシュの階層構造 |
| ルートハッシュは全データの要約 | どのデータが変更されてもルートハッシュが変わる |
| 包含証明は対数的に効率的 | 10 億件のデータでも 30 個のハッシュ値で証明可能 |
| CT と Sigstore で使われている | 追加専用の透明性ログとの相性が良い |

---

## [用語集](#glossary) {#glossary}

{: .labeled}
| 用語 | 説明 |
| -------------- | ------------------------------------------------------------------------------------------------ |
| マークル木 | ハッシュ値を木構造で組み合わせたデータ構造（Ralph Merkle が 1979 年に発明） |
| リーフノード | マークル木の最下層にある、元データのハッシュ値を持つノード |
| 中間ノード | 2 つの子ノードのハッシュ値を結合してハッシュ化したノード |
| ルートハッシュ | マークル木の最上位のハッシュ値で、全データの要約 |
| 包含証明 | 特定のデータがマークル木に含まれていることを、木全体を渡さずに証明する仕組み |
| SCT | Signed Certificate Timestamp の略で、CT ログが証明書の記録を証明するために発行するタイムスタンプ |

---

## [参考資料](#references) {#references}

<strong>マークル木</strong>

- [RFC 6962 - Certificate Transparency](https://datatracker.ietf.org/doc/html/rfc6962){:target="\_blank"}
  - Certificate Transparency の仕様（マークル木の使用方法を含む）

<strong>Sigstore</strong>

- [Rekor - Transparency Log](https://docs.sigstore.dev/logging/overview/){:target="\_blank"}
  - Sigstore の透明性ログ Rekor の概要
