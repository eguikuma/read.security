---
layout: default
title: ゼロトラストアーキテクチャ
---

# [appendix：ゼロトラストアーキテクチャ](#zero-trust-architecture) {#zero-trust-architecture}

## [はじめに](#introduction) {#introduction}

[04-authentication](../../04-authentication/) では、ゼロトラストを「何も信頼せず、常に検証する」と紹介しました

[05-access-control](../../05-access-control/) では、ABAC（属性ベースアクセス制御）がゼロトラストの実装に適していることを学びました

しかし、ゼロトラストの全体像、つまり「なぜ境界型セキュリティでは不十分なのか」「ゼロトラストは具体的にどのような原則で構成されるのか」については詳しく触れていません

この補足資料では、ゼロトラストアーキテクチャの考え方と、このリポジトリで学んだ概念がゼロトラストの中でどう位置づけられるかを学びます

---

## [このページで学ぶこと](#what-you-will-learn) {#what-you-will-learn}

- 境界型セキュリティの限界
- ゼロトラストの 3 つの原則
- このリポジトリで学んだ概念とゼロトラストの関係

---

## [目次](#table-of-contents) {#table-of-contents}

1. [境界型セキュリティの限界](#perimeter-security-limitations)
2. [ゼロトラストの 3 つの原則](#zero-trust-three-principles)
3. [ゼロトラストと認証](#zero-trust-and-authentication)
4. [ゼロトラストとアクセス制御](#zero-trust-and-access-control)
5. [ゼロトラストと暗号化](#zero-trust-and-encryption)
6. [マイクロセグメンテーション](#micro-segmentation)
7. [このリポジトリとの対応関係](#repository-correspondence)
8. [まとめ](#summary)
9. [用語集](#glossary)
10. [参考資料](#references)

---

## [境界型セキュリティの限界](#perimeter-security-limitations) {#perimeter-security-limitations}

### [境界型セキュリティとは](#what-is-perimeter-security) {#what-is-perimeter-security}

従来のセキュリティモデルは<strong>境界型セキュリティ</strong>（Perimeter Security）と呼ばれるアプローチです

組織のネットワークを<strong>「内側（信頼できる）」と「外側（信頼できない）」</strong>に分け、境界にファイアウォールや VPN を設置して外部からの攻撃を防ぐ方式です

```
インターネット（信頼できない）
        │
   [ファイアウォール / VPN]  ← 境界
        │
  社内ネットワーク（信頼できる）
    ├── サーバー A
    ├── サーバー B
    └── ユーザー端末
```

このモデルでは、境界の内側に入ったものは<strong>信頼済み</strong>として扱われます

### [なぜ境界型では不十分か](#why-perimeter-security-insufficient) {#why-perimeter-security-insufficient}

境界型セキュリティには以下の前提がありますが、これらの前提は崩れつつあります

{: .labeled}
| 前提 | 現実 |
| ---------------------- | -------------------------------------------------------------------- |
| 社内ネットワークは安全 | 内部犯行、マルウェア感染により内部からの攻撃が発生する |
| 攻撃者は外部にいる | フィッシングなどで正規の認証情報を入手した攻撃者は内部に見える |
| 社員は社内から接続する | リモートワーク、クラウドサービスの利用で「社内」の概念が曖昧になった |
| 境界は明確に定義できる | マイクロサービス、SaaS、モバイルデバイスで境界が拡散している |

境界型セキュリティの最大の問題は、<strong>境界を突破されると内部で自由に移動できる</strong>ことです

攻撃者が VPN の認証情報を入手すれば、境界の内側に入れます

内側は「信頼済み」として扱われるため、攻撃者は内部のリソースに広くアクセスできてしまいます

この「境界突破後の自由な移動」を<strong>ラテラルムーブメント</strong>（横方向の移動）と呼びます

---

## [ゼロトラストの 3 つの原則](#zero-trust-three-principles) {#zero-trust-three-principles}

<strong>ゼロトラスト</strong>は、ネットワークの位置（内側か外側か）に基づく信頼を廃止し、全てのアクセスを検証するセキュリティモデルです

NIST SP 800-207 では、ゼロトラストの核となる考え方を定義しています

### [原則 1：常に検証する（Never Trust, Always Verify）](#principle-never-trust-always-verify) {#principle-never-trust-always-verify}

ネットワークの内側にいることは、信頼の根拠にはなりません

全てのアクセスリクエストは、<strong>毎回</strong>認証と認可を行います

「一度ログインしたから信頼する」ではなく、「毎回のリクエストで身元と権限を確認する」アプローチです

これは 04-authentication で学んだ認証の概念の拡張です

セッションベースの認証では、ログイン後はセッションが有効な限りアクセスが許可されます

ゼロトラストでは、セッションの有効性だけでなく、アクセスの<strong>コンテキスト</strong>（時刻、場所、デバイスの状態など）も評価します

### [原則 2：最小権限（Least Privilege）](#principle-least-privilege) {#principle-least-privilege}

05-access-control で学んだ<strong>最小権限の原則</strong>を徹底します

ユーザーやアプリケーションには、必要な操作を行うための<strong>最小限の権限</strong>だけを付与します

ゼロトラストでは、この原則をさらに細かく適用します

たとえば、「データベースへのアクセス権」ではなく「特定のテーブルの読み取り権限のみ、業務時間中のみ」というように、権限を時間や条件で動的に制限します

### [原則 3：侵害を前提とする（Assume Breach）](#principle-assume-breach) {#principle-assume-breach}

<strong>攻撃者は既に内部に存在する</strong>という前提で設計します

境界型セキュリティが「攻撃者を境界の外に留める」ことを目標とするのに対し、ゼロトラストは「攻撃者が内部にいても被害を最小化する」ことを目標とします

この前提から導かれるのが、通信の暗号化、アクセスの詳細なログ記録、そして<strong>マイクロセグメンテーション</strong>（後述）です

---

## [ゼロトラストと認証](#zero-trust-and-authentication) {#zero-trust-and-authentication}

04-authentication で学んだ認証の仕組みは、ゼロトラストの中核です

ゼロトラストでは、認証を<strong>継続的</strong>に行います

### [継続的な認証](#continuous-authentication) {#continuous-authentication}

従来の認証モデルでは、ログイン時に一度だけ認証を行い、その後はセッションが有効な限り信頼します

ゼロトラストでは、ユーザーの状況が変化するたびに再評価を行います

{: .labeled}
| 従来の認証 | ゼロトラストの認証 |
| ------------------------ | -------------------------------------------------- |
| ログイン時に一度だけ認証 | アクセスのたびに認証・認可を評価 |
| セッションが有効なら信頼 | コンテキスト（場所、デバイス、時刻）の変化で再評価 |
| パスワードのみで認証 | 多要素認証（MFA）を標準化 |

04-authentication で学んだ<strong>多要素認証（MFA）</strong>は、ゼロトラストにおいて標準的な認証方式です

FIDO2 / パスキーのようなフィッシング耐性のある認証方式は、ゼロトラストの「常に検証する」原則に適しています

---

## [ゼロトラストとアクセス制御](#zero-trust-and-access-control) {#zero-trust-and-access-control}

05-access-control で学んだアクセス制御モデルは、ゼロトラストのアクセス判断の基盤です

### [ABAC との親和性](#abac-affinity) {#abac-affinity}

ゼロトラストのアクセス判断は、05-access-control で学んだ <strong>ABAC</strong>（属性ベースアクセス制御）と高い親和性があります

RBAC（ロールベースアクセス制御）は「この人はどのロールか」に基づいてアクセスを判断しますが、ゼロトラストではロールだけでは不十分です

ABAC では、以下のような<strong>動的な属性</strong>を組み合わせてアクセスを判断できます

{: .labeled}
| 属性カテゴリ | 評価する属性の例 |
| ------------------------- | ------------------------------------------------ |
| 主体（Subject）の属性 | ユーザーのロール、部署、セキュリティクリアランス |
| リソース（Object）の属性 | データの機密レベル、所有者 |
| 環境（Environment）の属性 | アクセス時刻、アクセス元の国、ネットワークの種類 |
| デバイスの属性 | OS のバージョン、パッチ適用状況、暗号化の有無 |

たとえば、「エンジニアが、業務時間中に、会社支給のデバイスから、パッチが最新のデバイスで、本番データベースの読み取りアクセスを要求した場合のみ許可する」というポリシーを表現できます

---

## [ゼロトラストと暗号化](#zero-trust-and-encryption) {#zero-trust-and-encryption}

### [内部通信も暗号化する](#encrypt-internal-communication) {#encrypt-internal-communication}

境界型セキュリティでは、社内ネットワーク内の通信は暗号化されないことがありました

「内側は安全」という前提に基づくためです

ゼロトラストでは「侵害を前提とする」ため、<strong>内部の通信も全て暗号化</strong>します

02-tls で学んだ TLS は、外部との通信だけでなく、内部のサービス間通信にも適用されます

<strong>mTLS</strong>（相互 TLS 認証）では、クライアントとサーバーの<strong>両方</strong>が証明書を提示して相互に認証します

通常の TLS ではサーバーのみが証明書を提示しますが、mTLS ではクライアントも自身の身元を証明します

これにより、サービス間の通信で「どのサービスがアクセスしているか」を暗号的に検証できます

---

## [マイクロセグメンテーション](#micro-segmentation) {#micro-segmentation}

### [ラテラルムーブメントの防止](#lateral-movement-prevention) {#lateral-movement-prevention}

<strong>マイクロセグメンテーション</strong>は、ネットワークを細かい単位に分割し、セグメント間の通信を制御する手法です

境界型セキュリティでは、内部ネットワークは 1 つの大きな信頼ゾーンです

攻撃者が内部に侵入すると、全てのリソースに到達可能です

マイクロセグメンテーションでは、サービスやワークロードごとにセグメントを分け、<strong>セグメント間の通信を明示的に許可する</strong>構成にします

```
境界型：
  社内ネットワーク
    ├── Web サーバー ←→ DB サーバー ←→ ファイルサーバー
    └── 全て自由に通信可能

マイクロセグメンテーション：
  [Web サーバー] ──許可──→ [API サーバー] ──許可──→ [DB サーバー]
                                                       ↑
  [Web サーバー] ──拒否──────────────────────────────────┘
```

この例では、Web サーバーから DB サーバーへの直接アクセスは拒否されます

Web サーバーが侵害されても、API サーバーを経由しなければ DB にアクセスできないため、攻撃者の移動が制限されます

マイクロセグメンテーションは、オーケストレーションの学習で扱うネットワークポリシー（Kubernetes の NetworkPolicy など）として実装されることがあります

---

## [このリポジトリとの対応関係](#repository-correspondence) {#repository-correspondence}

ゼロトラストは特定の技術ではなく、セキュリティの<strong>設計思想</strong>です

このリポジトリで学んだ概念は、ゼロトラストの各側面を支えています

{: .labeled}
| ゼロトラストの要素 | 対応するトピック | 概念 |
| -------------------- | ----------------------- | ------------------------------------------- |
| 通信の暗号化 | 01-cryptography、02-tls | 全ての通信を TLS / mTLS で暗号化 |
| 証明書による身元証明 | 03-certificate | サービス間の mTLS で証明書を使った相互認証 |
| 継続的な認証 | 04-authentication | 多要素認証、コンテキストに基づく再評価 |
| 動的なアクセス制御 | 05-access-control | ABAC による属性ベースの細粒度なアクセス判断 |
| 入力検証と多層防御 | 06-application-security | 信頼境界をサービスごとに設定 |
| 依存関係の検証 | 07-supply-chain | ソフトウェアの署名と検証による信頼の確立 |

ゼロトラストの考え方は、このリポジトリで学んだセキュリティの各要素を<strong>「ネットワーク位置に関係なく常に適用する」</strong>という方針で統合したものです

---

## [まとめ](#summary) {#summary}

{: .labeled}
| ポイント | 説明 |
| ------------------------------------------------------ | ---------------------------------------------------------------- |
| 境界型セキュリティは「内側は安全」を前提とする | リモートワーク、クラウド、内部犯行により前提が崩れている |
| ゼロトラストは 3 つの原則で構成される | 常に検証する、最小権限、侵害を前提とする |
| 認証は継続的に行う | ログイン時だけでなく、コンテキストの変化に応じて再評価する |
| ABAC がゼロトラストのアクセス制御に適している | 主体、リソース、環境、デバイスの属性を動的に評価できる |
| 内部通信も暗号化する | mTLS でサービス間の相互認証と暗号化を実現する |
| マイクロセグメンテーションがラテラルムーブメントを防ぐ | ネットワークを細かく分割し、セグメント間の通信を明示的に制御する |

---

## [用語集](#glossary) {#glossary}

{: .labeled}
| 用語 | 説明 |
| -------------------------- | ------------------------------------------------------------------------------------ |
| 境界型セキュリティ | ネットワークの内側と外側を分け、境界で防御するセキュリティモデル |
| ゼロトラスト | ネットワーク位置に基づく信頼を廃止し、全てのアクセスを検証するセキュリティモデル |
| ラテラルムーブメント | 攻撃者が内部ネットワーク内で横方向に移動してリソースにアクセスすること |
| mTLS | Mutual TLS の略で、クライアントとサーバーの両方が証明書を提示して相互認証する TLS |
| マイクロセグメンテーション | ネットワークを細かいセグメントに分割し、セグメント間の通信を制御する手法 |
| 継続的な認証 | ログイン時だけでなく、アクセスのたびにコンテキストを評価して認証判断を行うアプローチ |

---

## [参考資料](#references) {#references}

<strong>NIST</strong>

- [NIST SP 800-207 - Zero Trust Architecture](https://csrc.nist.gov/pubs/sp/800/207/final){:target="\_blank"}
  - NIST によるゼロトラストアーキテクチャの定義と設計原則
