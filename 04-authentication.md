<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 04-authentication：認証と認可（セッション、トークン、OAuth）

## はじめに

前のトピック [03-certificate](./03-certificate.md) では、証明書と PKI（Public Key Infrastructure）の仕組みを学びました

- 証明書は公開鍵と身元情報を結びつけ、認証局のデジタル署名で保証される
- X.509 は証明書の標準形式であり、Subject、Issuer、Public Key、Validity、SAN などのフィールドを含む
- PKI は認証局の階層構造（ルート CA → 中間 CA → エンドエンティティ）による信頼の連鎖で成り立つ
- ブラウザはトラストストアのルート CA を起点に、証明書チェーンの署名・有効期間・ドメイン名を検証する
- Certificate Transparency は認証局の不正発行を公開ログで監視する仕組みである

03-certificate の最後に、こう問いかけました

<strong>証明書によってサーバーの身元は確認できるようになりましたが、サーバーにアクセスするユーザーの身元はどのように確認するのでしょうか？</strong>

パスワードによる認証は、内部的にどのような仕組みで安全に行われているのでしょうか？

「認証」（あなたは誰か）と「認可」（あなたは何ができるか）は、どう違うのでしょうか？

Web サービスで広く使われる OAuth や JWT は、どのような原理で動いているのでしょうか？

このトピックでは、<strong>認証と認可</strong>の仕組みを学びます

ユーザーの身元をどのように確認し、確認された身元に基づいてどのように権限を管理するのか、その原理を理解します

---

## 日常の例え

認証と認可の仕組みを、日常の例えで見てみましょう

<strong>認証と認可 = パスポートと搭乗券</strong>

空港のチェックインカウンターでは、まずパスポートを提示して<strong>本人確認</strong>を行います

パスポートで本人だと確認された後、搭乗券が渡されます

搭乗券には「どの便に乗れるか」「座席はどこか」という<strong>権限</strong>が記載されています

パスポートだけでは飛行機に乗れませんし、搭乗券だけでは本人確認ができません

認証は「あなたは誰か」を確認するパスポートの提示にあたり、認可は「あなたは何ができるか」を決める搭乗券の発行にあたります

<strong>セッション = レストランの食券番号</strong>

レストランで注文すると、番号が書かれた食券を渡されます

料理ができたとき、店員は食券の番号を呼びます

お店の側では、番号と注文内容を紐づけた記録を管理しています

食券の番号自体には注文内容は書かれていませんが、その番号をお店の記録と照合すれば、誰の注文かが分かります

Web のセッションも同じで、サーバーがセッション ID という番号を発行し、サーバー側の記録と照合することで「誰がログインしているか」を管理しています

<strong>トークン（JWT） = 映画チケット</strong>

映画チケットには、映画のタイトル、上映時刻、座席番号、劇場名がすべて印刷されています

チケットを受け取った後は、劇場のスタッフがチケットを見るだけで入場を許可できます

スタッフは別のシステムに問い合わせる必要がありません

JWT も同じで、トークン自体にユーザー情報や権限が含まれており、サーバーはトークンの署名を検証するだけで認証を完了できます

<strong>OAuth = バレーパーキングの鍵</strong>

高級ホテルのバレーパーキングでは、車の持ち主がバレーキーを係員に渡します

バレーキーはエンジンの始動と低速走行だけが可能で、トランクを開けたり、グローブボックスにアクセスしたりすることはできません

車の持ち主は、すべての機能を使えるマスターキーを渡す代わりに、<strong>必要最小限の権限だけを持つ鍵</strong>を渡します

OAuth も同じで、ユーザーはパスワード（マスターキー）を第三者アプリに渡す代わりに、限定された権限を持つアクセストークン（バレーキー）を発行します

---

## このページで学ぶこと

このページでは、以下の概念を学びます

<strong>認証と認可の基本</strong>

- <strong>認証（Authentication）</strong>
  - 「あなたは誰か」を確認するプロセス
- <strong>認可（Authorization）</strong>
  - 「あなたは何ができるか」を決定するプロセス

<strong>パスワードとセッション</strong>

- <strong>パスワードの安全な管理</strong>
  - ハッシュ化、ソルト、鍵導出関数による保護の仕組み
- <strong>セッションベース認証</strong>
  - Cookie とセッション ID によるステートフルな認証の仕組み

<strong>トークンと OAuth</strong>

- <strong>トークンベース認証</strong>
  - JWT によるステートレスな認証の仕組み
- <strong>OAuth 2.0</strong>
  - パスワードを共有せずに権限を委譲する仕組み

<strong>多要素認証と現代の課題</strong>

- <strong>多要素認証（MFA）</strong>
  - 複数の認証要素を組み合わせて安全性を高める仕組み
- <strong>認証の現代的な課題</strong>
  - パスワードレス認証とゼロトラストの考え方

---

## 目次

1. [認証と認可の違い](#認証と認可の違い)
2. [パスワードの安全な管理](#パスワードの安全な管理)
3. [セッションベース認証](#セッションベース認証)
4. [トークンベース認証](#トークンベース認証)
5. [OAuth 2.0](#oauth-20)
6. [多要素認証（MFA）](#多要素認証mfa)
7. [認証の現代的な課題](#認証の現代的な課題)
8. [次のトピックへ](#次のトピックへ)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## 認証と認可の違い

### 認証（Authentication）とは

<strong>認証</strong>（Authentication）は、「あなたは誰か」を確認するプロセスです

[03-certificate](./03-certificate.md) で学んだ証明書の仕組みは、TLS ハンドシェイクにおける<strong>サーバーの認証</strong>でした

証明書によってサーバーが「確かに example.com である」と確認できるのと同様に、ユーザーの認証は「確かにこのアカウントの持ち主である」と確認するプロセスです

認証の手段は、パスワード、生体情報、物理デバイスなど多岐にわたりますが、目的は常に同じです

<strong>この人は本当に本人なのか？</strong>

この問いに答えることが認証の役割です

### 認可（Authorization）とは

<strong>認可</strong>（Authorization）は、「あなたは何ができるか」を決定するプロセスです

認証が「身元の確認」であるのに対し、認可は「権限の付与」です

認証と認可は密接に関連していますが、別のプロセスです

| 観点     | 認証（Authentication）           | 認可（Authorization）            |
| -------- | -------------------------------- | -------------------------------- |
| 問い     | あなたは誰か？                   | あなたは何ができるか？           |
| 目的     | 身元の確認                       | 権限の決定                       |
| 順序     | 先に行われる                     | 認証の後に行われる               |
| 判定基準 | パスワード、生体情報、証明書など | 役割、スコープ、ポリシーなど     |
| 例       | ログイン画面でのパスワード入力   | 管理者だけがユーザーを削除できる |

この順序は重要です

<strong>認証なしに認可はできません</strong>

「この人は誰か」が分からなければ、「この人は何ができるか」を判断することもできません

まず認証で身元を確認し、その後に認可で権限を決定する、という流れが基本です

---

## パスワードの安全な管理

### なぜパスワードをそのまま保存してはいけないか

ユーザー認証の最も基本的な方法はパスワードです

しかし、パスワードを<strong>平文</strong>（そのままの文字列）でデータベースに保存してはいけません

データベースが攻撃者に漏洩した場合、保存されたすべてのパスワードがそのまま読み取られてしまうからです

多くのユーザーは複数のサービスで同じパスワードを使い回しているため、1 つのサービスからの漏洩が他のサービスへの不正アクセスにつながります

パスワードの安全な管理には、[01-cryptography](./01-cryptography.md) で学んだ<strong>ハッシュ関数</strong>が使われます

ハッシュ関数は任意のデータを固定長の値に変換する一方向性の関数です

パスワードをハッシュ化して保存すれば、データベースが漏洩してもハッシュ値から元のパスワードを復元することはできません

### ソルトとハッシュ

パスワードを単にハッシュ化するだけでは十分ではありません

<strong>レインボーテーブル攻撃</strong>という手法が存在するからです

レインボーテーブルとは、よく使われるパスワードとそのハッシュ値をあらかじめ計算して一覧にしたデータベースです

攻撃者は漏洩したハッシュ値をレインボーテーブルと照合するだけで、元のパスワードを特定できてしまいます

この攻撃を防ぐのが<strong>ソルト</strong>です

ソルトとは、パスワードをハッシュ化する前に付加するランダムな文字列です

```
  ソルトなしの場合（レインボーテーブル攻撃に脆弱）：

  ユーザー A のパスワード: password123
  ユーザー B のパスワード: password123
        │                       │
        ▼                       ▼
  ハッシュ値: ef92b...      ハッシュ値: ef92b...
  （同じパスワードは同じハッシュ値になる）


  ソルトありの場合（レインボーテーブル攻撃を防御）：

  ユーザー A: password123 + ソルト "x7k2m"
  ユーザー B: password123 + ソルト "p3j9q"
        │                       │
        ▼                       ▼
  ハッシュ値: a1d4f...      ハッシュ値: 8bc3e...
  （同じパスワードでも異なるハッシュ値になる）
```

ソルトはユーザーごとに異なるランダムな値を生成し、ハッシュ値と一緒にデータベースに保存します

ソルト自体は秘密にする必要はありません

ソルトの役割は、同じパスワードでも異なるハッシュ値を生成することで、事前計算による攻撃を無効化することです

ログイン時の検証は以下の流れで行われます

1. ユーザーがパスワードを入力する
2. データベースからそのユーザーのソルトを取得する
3. 入力されたパスワードとソルトを結合してハッシュ化する
4. 計算したハッシュ値とデータベースに保存されたハッシュ値を比較する
5. 一致すれば認証成功、不一致なら認証失敗

### 鍵導出関数

ソルト付きのハッシュ化でレインボーテーブル攻撃は防げますが、もう 1 つの攻撃手法があります

<strong>ブルートフォース攻撃</strong>（総当たり攻撃）です

攻撃者がパスワードの候補を片端からハッシュ化し、漏洩したハッシュ値と比較する手法です

SHA-256 のような汎用ハッシュ関数は高速に設計されているため、攻撃者は 1 秒間に数十億回のハッシュ計算が可能です

この問題に対処するのが<strong>鍵導出関数</strong>（Key Derivation Function）です

鍵導出関数は、ハッシュ計算を<strong>意図的に遅くする</strong>ことで、ブルートフォース攻撃のコストを大幅に引き上げます

この「意図的に遅くする」処理を<strong>ストレッチング</strong>と呼びます

| 関数   | 特徴                               |
| ------ | ---------------------------------- |
| bcrypt | 計算コストを調整可能な鍵導出関数   |
| Argon2 | メモリ使用量も調整可能な鍵導出関数 |

<strong>bcrypt</strong> は、内部でハッシュ計算を何千回も繰り返すことで、1 回のパスワード検証に数百ミリ秒かかるように設計されています

正規のユーザーにとって数百ミリ秒の遅延は気にならない程度ですが、攻撃者にとっては 1 秒間に数回しか試行できなくなり、ブルートフォース攻撃が現実的でなくなります

<strong>Argon2</strong> は、計算コストに加えて<strong>メモリ使用量</strong>も調整できます

GPU や専用ハードウェアを使った並列攻撃に対して、大量のメモリを要求することで対抗します

---

## セッションベース認証

### HTTP はステートレス

Web で使われる HTTP プロトコルは<strong>ステートレス</strong>（状態を持たない）です

HTTP の各リクエストは独立しており、サーバーは前のリクエストの情報を覚えていません

つまり、1 回目のリクエストでログインに成功しても、2 回目のリクエストではサーバーはそのことを知りません

リクエストのたびにパスワードを送信するのは非現実的です

そこで、「一度ログインしたら、しばらくの間はログイン状態を維持する」ための仕組みが必要になります

それが<strong>セッション</strong>です

### Cookie とセッション ID

セッションベース認証は、<strong>Cookie</strong> と<strong>セッション ID</strong> の組み合わせで実現されます

Cookie は RFC 6265 で定義された、ブラウザとサーバーの間で小さなデータをやり取りする仕組みです

```
  セッションベース認証の流れ：

  ┌──────────┐                              ┌──────────┐
  │ ブラウザ   │── ① ログイン要求 ─────────→│  サーバー  │
  │          │   （ID とパスワード）         │          │
  └──────────┘                              └────┬─────┘
                                                  │ ② 認証成功
                                                  │    セッション ID を生成
                                                  │    サーバー側に保存
                                                  ▼
  ┌──────────┐                              ┌──────────┐
  │ ブラウザ   │←─ ③ Set-Cookie ────────────│  サーバー  │
  │          │   （セッション ID を送信）    │          │
  └──────────┘                              └──────────┘
       │ ④ ブラウザが Cookie を保存
       │
       ▼
  ┌──────────┐                              ┌──────────┐
  │ ブラウザ   │── ⑤ 以降のリクエスト ──────→│  サーバー  │
  │          │   （Cookie にセッション ID）  │          │
  └──────────┘                              └────┬─────┘
                                                  │ ⑥ セッション ID で
                                                  │    ユーザーを特定
                                                  ▼
                                            ┌──────────┐
                                            │ セッション  │
                                            │ ストア     │
                                            │ ユーザー A │
                                            │ ユーザー B │
                                            └──────────┘
```

サーバーは Set-Cookie ヘッダでセッション ID をブラウザに送り、ブラウザは以降のリクエストに自動的にその Cookie を含めます

サーバーは受け取ったセッション ID をセッションストア（メモリやデータベース）と照合し、どのユーザーのリクエストかを特定します

Cookie にはセキュリティに関する重要な属性があります

| 属性     | 役割                                                                                  |
| -------- | ------------------------------------------------------------------------------------- |
| Secure   | HTTPS 接続でのみ Cookie を送信する（TLS で保護された通信でのみ使われる）              |
| HttpOnly | JavaScript からのアクセスを禁止する（XSS 攻撃によるセッション ID の窃取を防ぐ）       |
| SameSite | 異なるサイトからのリクエストに Cookie を含めるかを制御する（CSRF 攻撃の防御に関わる） |

Secure 属性は [02-tls](./02-tls.md) で学んだ TLS と直接関係しています

TLS で暗号化された通信でのみ Cookie を送信することで、通信経路上でのセッション ID の盗聴を防ぎます

### セッションの課題

セッションベース認証には、いくつかの課題があります

<strong>サーバー側の状態管理</strong>：セッション情報はサーバー側に保存されるため、サーバーの台数が増えると、すべてのサーバーがセッション情報を共有する必要があります

ユーザーが最初にサーバー A でログインしても、次のリクエストがサーバー B に振り分けられた場合、サーバー B にはセッション情報がありません

この問題を解決するには、共有のセッションストア（データベースや分散キャッシュ）が必要になり、システムの複雑さが増します

<strong>セッション固定攻撃</strong>：攻撃者が事前に知っているセッション ID をユーザーに使わせ、そのセッション ID でユーザーのログイン状態を乗っ取る攻撃です

対策として、ログイン成功時にセッション ID を必ず再生成します

<strong>セッションハイジャック</strong>：攻撃者がセッション ID を何らかの方法で盗み取り、そのユーザーになりすます攻撃です

Cookie の Secure 属性と HttpOnly 属性は、この攻撃のリスクを低減する仕組みです

---

## トークンベース認証

### なぜトークンか

セッションベース認証では、サーバーがセッション情報を保持する必要がありました

サーバーの台数が増えるほど、セッション情報の共有が課題になります

<strong>トークンベース認証</strong>は、この課題を解決するアプローチです

トークンベース認証では、認証に必要な情報を<strong>トークン自体に含める</strong>ことで、サーバー側にセッション情報を保持する必要をなくします

サーバーはトークンの署名を検証するだけで認証を完了でき、セッションストアへの問い合わせは不要です

この「サーバー側に状態を持たない」性質を<strong>ステートレス</strong>と呼びます

### JWT の構造

<strong>JWT</strong>（JSON Web Token、RFC 7519）は、トークンベース認証で広く使われるトークン形式です

JWT は 3 つの部分をドット（.）で連結した文字列です

```
  JWT の構造：

  eyJhbGci...  .  eyJzdWIi...  .  SflKxwRJ...
  ┌─────────┐    ┌─────────┐    ┌─────────┐
  │ ヘッダー   │    │ ペイロード │    │  署名    │
  └─────────┘    └─────────┘    └─────────┘
  署名アルゴリズム   ユーザー情報     改ざん検出
  トークン種類       有効期限
                    発行者
```

<strong>ヘッダー</strong>は、トークンの種類と署名アルゴリズムを指定します

<strong>ペイロード</strong>は、ユーザーに関する情報（<strong>クレーム</strong>と呼ばれる）を含みます

RFC 7519 では、以下の標準クレームが定義されています

| クレーム | 名前            | 意味                                |
| -------- | --------------- | ----------------------------------- |
| iss      | Issuer          | トークンを発行した主体              |
| sub      | Subject         | トークンの対象（通常はユーザー ID） |
| aud      | Audience        | トークンの受信者（対象のサービス）  |
| exp      | Expiration Time | トークンの有効期限                  |
| iat      | Issued At       | トークンの発行日時                  |

<strong>署名</strong>は、ヘッダーとペイロードを結合したデータに対して生成されます

```
  JWT の署名と検証：

  ┌──────────────────────────┐
  │ ヘッダー + ペイロード      │
  └────────────┬─────────────┘
               │
               ▼ 秘密鍵で署名
        ┌────────────┐
        │    署名     │
        └────────────┘

  検証時：
  ┌──────────────────────────┐    ┌────────────┐
  │ ヘッダー + ペイロード      │    │  受信した署名 │
  └────────────┬─────────────┘    └──────┬─────┘
               │                         │
               ▼ 公開鍵（または秘密鍵）で検証  │
        ┌────────────┐                   │
        │  計算した署名  │───── 一致？ ─────┘
        └────────────┘
        一致 → 改ざんなし（信頼できる）
        不一致 → 改ざんあり（拒否する）
```

署名の仕組みは [01-cryptography](./01-cryptography.md) で学んだデジタル署名と同じ原理です

サーバーはトークンの署名を検証することで、トークンの内容が改ざんされていないことを確認できます

ペイロードは Base64URL エンコードされているだけで<strong>暗号化されていない</strong>点に注意が必要です

ペイロードの内容は誰でも読めるため、パスワードや秘密情報をペイロードに含めてはいけません

JWT が保証するのは<strong>完全性</strong>（改ざんされていないこと）と<strong>真正性</strong>（発行者が正しいこと）であり、<strong>機密性</strong>（内容を隠すこと）ではありません

### トークンのライフサイクル

トークンベース認証では、通常 2 種類のトークンが使われます

<strong>アクセストークン</strong>は、リソースへのアクセスに使われるトークンです

有効期間は短く設定されます（数分から数十分程度）

<strong>リフレッシュトークン</strong>は、新しいアクセストークンを取得するためのトークンです

有効期間はアクセストークンよりも長く設定されます（数日から数週間程度）

```
  トークンのライフサイクル：

  ┌──────────┐                              ┌──────────┐
  │ クライアント │── ① ログイン ──────────────→│  サーバー  │
  └──────────┘                              └────┬─────┘
       ▲                                         │
       │    ② アクセストークン（短命）             │
       │       + リフレッシュトークン（長命）      │
       └──────────────────────────────────────────┘

  ┌──────────┐                              ┌──────────┐
  │ クライアント │── ③ アクセストークンで ────→│  サーバー  │
  │          │    リソースにアクセス          │          │
  └──────────┘                              └──────────┘

  （アクセストークンが期限切れになったら）

  ┌──────────┐                              ┌──────────┐
  │ クライアント │── ④ リフレッシュトークンで →│  サーバー  │
  │          │    新しいアクセストークンを要求 │          │
  └──────────┘                              └────┬─────┘
       ▲                                         │
       │    ⑤ 新しいアクセストークンを発行        │
       └──────────────────────────────────────────┘
```

なぜ 2 種類のトークンに分けるのでしょうか

アクセストークンはリクエストのたびに送信されるため、盗まれるリスクが相対的に高くなります

アクセストークンの有効期間を短くすることで、盗まれた場合の影響を限定できます

一方、リフレッシュトークンはアクセストークンの再発行時にしか使わないため、盗まれるリスクが低くなります

ステートレスなトークンには課題もあります

セッションベース認証ではサーバー側のセッションを削除すれば即座に無効化できますが、JWT は有効期限が切れるまで<strong>無効化が困難</strong>です

トークンの内容がトークン自体に含まれており、サーバーがトークンの有効性を管理していないからです

この課題に対する一般的な対策は、アクセストークンの有効期間を十分に短くすることです

---

## OAuth 2.0

### なぜ OAuth が必要か

あるサービスのデータに別のアプリケーションからアクセスしたい場合を考えます

たとえば、写真編集アプリがクラウドストレージの写真にアクセスする場合です

OAuth がなければ、ユーザーはクラウドストレージのパスワードを写真編集アプリに直接渡す必要があります

しかし、これには深刻な問題があります

- 写真編集アプリがパスワードを保存するため、漏洩リスクが生じる
- 写真編集アプリにはクラウドストレージの<strong>すべての権限</strong>が与えられてしまう（写真の閲覧だけでなく、削除やアカウント設定の変更も可能）
- パスワードを変更すると、すべての連携アプリが使えなくなる
- 特定のアプリだけのアクセスを取り消すことができない

<strong>OAuth 2.0</strong>（RFC 6749）は、これらの問題を解決する<strong>認可のフレームワーク</strong>です

OAuth 2.0 の核心は、<strong>パスワードを共有せずに、限定された権限を安全に委譲する</strong>ことです

### OAuth 2.0 の登場人物

RFC 6749 では、OAuth 2.0 に 4 つの役割が定義されています

| 役割                                 | 説明                                     | 写真編集の例                 |
| ------------------------------------ | ---------------------------------------- | ---------------------------- |
| リソースオーナー（Resource Owner）   | データの所有者（通常はユーザー）         | ユーザー自身                 |
| クライアント（Client）               | リソースにアクセスしたいアプリケーション | 写真編集アプリ               |
| 認可サーバー（Authorization Server） | アクセストークンを発行するサーバー       | クラウドストレージの認可機能 |
| リソースサーバー（Resource Server）  | 保護されたリソースをホストするサーバー   | クラウドストレージの API     |

> The authorization server issues access tokens to the client after successfully authenticating the resource owner and obtaining authorization.

> 認可サーバーは、リソースオーナーの認証と認可の取得に成功した後、クライアントにアクセストークンを発行します

RFC 6749 が述べるように、認可サーバーはリソースオーナー（ユーザー）の意思を確認した上で、クライアント（アプリケーション）にアクセストークンを発行します

### 認可コードフロー

OAuth 2.0 には複数のフロー（認可の流れ）が定義されていますが、最も広く使われているのが<strong>認可コードフロー</strong>（Authorization Code Flow）です

```
  認可コードフローの流れ：

  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
  │  ユーザー  │    │ 写真編集   │    │ 認可サーバー │    │ リソース   │
  │          │    │ アプリ    │    │          │    │ サーバー   │
  └────┬─────┘    └────┬─────┘    └────┬─────┘    └────┬─────┘
       │               │               │               │
       │ ① 写真を       │               │               │
       │   編集したい    │               │               │
       │──────────────→│               │               │
       │               │               │               │
       │    ② 認可サーバーにリダイレクト  │               │
       │←──────────────│               │               │
       │               │               │               │
       │ ③ ログイン画面で認証            │               │
       │──────────────────────────────→│               │
       │               │               │               │
       │ ④「写真の閲覧を許可しますか？」 │               │
       │←──────────────────────────────│               │
       │               │               │               │
       │ ⑤ 許可する     │               │               │
       │──────────────────────────────→│               │
       │               │               │               │
       │    ⑥ 認可コードを付けてリダイレクト              │
       │←──────────────────────────────│               │
       │──────────────→│               │               │
       │               │               │               │
       │               │ ⑦ 認可コードを │               │
       │               │   トークンに交換│               │
       │               │──────────────→│               │
       │               │               │               │
       │               │ ⑧ アクセス     │               │
       │               │   トークン     │               │
       │               │←──────────────│               │
       │               │               │               │
       │               │ ⑨ アクセストークンで            │
       │               │   写真を取得   │               │
       │               │──────────────────────────────→│
       │               │               │               │
       │               │ ⑩ 写真データ  │               │
       │               │←──────────────────────────────│
       │               │               │               │
```

このフローのポイントは、ユーザーのパスワードが写真編集アプリに渡らないことです

ユーザーは認可サーバー（クラウドストレージ自身の画面）で直接ログインし、認可サーバーがアクセストークンを発行します

認可コードフローでは、⑥で認可コードが URL のクエリパラメータに含まれてリダイレクトされます

この認可コードは短命で 1 回しか使えず、⑦でアクセストークンに交換する際にはクライアントの秘密情報（クライアントシークレット）も必要です

このように 2 段階に分けることで、アクセストークンがブラウザの履歴やログに残るリスクを防いでいます

<strong>PKCE</strong>（Proof Key for Code Exchange）は、認可コードフローをさらに安全にする拡張です

モバイルアプリやシングルページアプリケーションでは、クライアントシークレットを安全に保管できません

PKCE は、認可リクエスト時にランダムな値（コードベリファイア）を生成し、そのハッシュ値（コードチャレンジ）を認可サーバーに送ります

トークン交換時にコードベリファイアを提示し、認可サーバーがハッシュ値を検証することで、認可コードを横取りした攻撃者がトークンを取得することを防ぎます

### スコープとアクセス制御

OAuth 2.0 では、<strong>スコープ</strong>（Scope）によってアクセストークンの権限を制限します

> The authorization and token endpoints allow the client to specify the scope of the access request using the "scope" request parameter.

> 認可エンドポイントとトークンエンドポイントにおいて、クライアントは "scope" リクエストパラメータを使用してアクセス要求のスコープを指定できます

スコープの例として、あるクラウドストレージの API が以下のスコープを定義しているとします

- `photos:read`：写真の閲覧
- `photos:write`：写真のアップロード・編集
- `account:read`：アカウント情報の閲覧
- `account:write`：アカウント設定の変更

写真編集アプリは `photos:read` と `photos:write` のスコープだけを要求すれば十分であり、`account:write` のような不要な権限を要求する必要はありません

これは<strong>最小権限の原則</strong>（Principle of Least Privilege）の実践です

必要最小限の権限だけを付与することで、アクセストークンが漏洩した場合の被害を限定できます

---

## 多要素認証（MFA）

### 認証の 3 要素

パスワードだけに頼る認証には限界があります

パスワードは漏洩する可能性があり、フィッシングやブルートフォース攻撃で破られることもあります

<strong>多要素認証</strong>（Multi-Factor Authentication、MFA）は、複数の種類の認証要素を組み合わせることでセキュリティを強化する仕組みです

認証要素は 3 つの種類に分類されます

| 要素     | 説明                                      | 例                               |
| -------- | ----------------------------------------- | -------------------------------- |
| 知識要素 | 本人だけが<strong>知っている</strong>もの | パスワード、PIN、秘密の質問      |
| 所持要素 | 本人だけが<strong>持っている</strong>もの | スマートフォン、セキュリティキー |
| 生体要素 | 本人の<strong>身体的特徴</strong>         | 指紋、顔、虹彩                   |

MFA の考え方は「<strong>異なる種類</strong>の要素を組み合わせる」ことです

パスワード（知識要素）を 2 つ使っても、それは多要素認証ではありません

なぜなら、同じ種類の要素は同じ方法で攻撃される可能性があるからです

パスワード（知識要素）とスマートフォンの認証コード（所持要素）を組み合わせることで、たとえパスワードが漏洩しても、スマートフォンを持っていなければログインできなくなります

### ワンタイムパスワード（TOTP）

<strong>TOTP</strong>（Time-based One-Time Password）は、MFA で広く使われるワンタイムパスワードの仕組みです

認証アプリ（Google Authenticator など）が 30 秒ごとに変わる 6 桁のコードを生成し、そのコードをログイン時に入力します

TOTP の仕組みは、[01-cryptography](./01-cryptography.md) で学んだ<strong>HMAC</strong>（Hash-based Message Authentication Code）を応用しています

```
  TOTP の仕組み：

  ┌───────────────────────────────────────┐
  │ 初期設定（1回だけ）                     │
  │                                       │
  │  サーバーが共有秘密（Secret）を生成     │
  │  ユーザーが認証アプリに登録（QR コード） │
  │  サーバーとアプリが同じ Secret を保持    │
  └───────────────────────────────────────┘

  ┌──────────────┐              ┌──────────────┐
  │ 認証アプリ     │              │   サーバー     │
  │              │              │              │
  │ Secret       │              │ Secret       │
  │    +         │              │    +         │
  │ 現在時刻      │              │ 現在時刻      │
  │    │         │              │    │         │
  │    ▼         │              │    ▼         │
  │ HMAC で計算   │              │ HMAC で計算   │
  │    │         │              │    │         │
  │    ▼         │              │    ▼         │
  │ 6桁コード生成  │── 一致？ ──→│ 6桁コード生成  │
  │ （例：482901）│              │ （例：482901）│
  └──────────────┘              └──────────────┘
```

サーバーと認証アプリは同じ共有秘密と同じ時刻を使って HMAC を計算するため、同じコードが生成されます

コードは 30 秒ごとに変わるため、盗み見られても短時間しか使えません

TOTP はインターネット接続がなくても動作する点が大きなメリットです

サーバーと認証アプリはあらかじめ共有秘密を登録しておくため、コード生成時に通信は不要です

### FIDO2 とパスキー

<strong>FIDO2</strong> は、パスワードに依存しない認証の標準です

FIDO2 は [01-cryptography](./01-cryptography.md) で学んだ<strong>公開鍵暗号</strong>の仕組みを認証に応用しています

```
  FIDO2 の認証フロー：

  ┌──────────┐                              ┌──────────┐
  │ ユーザーの  │                              │  サーバー  │
  │ デバイス   │                              │          │
  └────┬─────┘                              └────┬─────┘
       │ ① ログイン要求                          │
       │────────────────────────────────────────→│
       │                                         │
       │ ② チャレンジ（ランダムな値）を送信        │
       │←────────────────────────────────────────│
       │                                         │
       │ ③ ユーザーが生体認証や PIN で            │
       │   デバイスのロックを解除                 │
       │                                         │
       │ ④ デバイスの秘密鍵でチャレンジに署名     │
       │                                         │
       │ ⑤ 署名をサーバーに送信                   │
       │────────────────────────────────────────→│
       │                                         │
       │                   ⑥ 登録済みの公開鍵で   │
       │                      署名を検証          │
       │                                         │
       │ ⑦ 認証成功                               │
       │←────────────────────────────────────────│
       │                                         │
```

FIDO2 では、ユーザーのデバイスが秘密鍵を保持し、サーバーは対応する公開鍵だけを保存します

ログイン時にサーバーがランダムなチャレンジを送り、デバイスが秘密鍵で署名して返します

サーバーは公開鍵で署名を検証し、認証を行います

<strong>パスキー</strong>（Passkey）は FIDO2 の仕組みをより使いやすくした実装です

FIDO2 とパスキーが従来の認証と大きく異なる点は、<strong>フィッシング耐性</strong>です

パスワードベースの認証では、偽のログイン画面にパスワードを入力してしまう（フィッシング）リスクがあります

FIDO2 では、秘密鍵がデバイスから外に出ることはなく、認証時にサーバーのドメインが自動的に検証されるため、偽のサイトに認証情報を送信することが原理的にできません

---

## 認証の現代的な課題

### パスワードの限界

パスワードは最も広く使われている認証手段ですが、いくつかの根本的な問題を抱えています

<strong>クレデンシャルスタッフィング</strong>：あるサービスから漏洩したユーザー名とパスワードの組み合わせを、別のサービスに対して大量に試行する攻撃です

パスワードの使い回しが原因で、1 つのサービスの漏洩が他のサービスへの侵害に連鎖します

<strong>フィッシング</strong>：正規のサイトに見せかけた偽のサイトにユーザーを誘導し、パスワードを入力させる攻撃です

メールやメッセージのリンクをクリックさせる手法が一般的です

これらの問題は、パスワードという仕組み自体の限界を示しています

パスワードは「知識要素」であるため、知っている情報が漏洩すれば攻撃者も同じ情報を使えてしまいます

<strong>パスワードレス認証</strong>は、パスワードを使わずに認証を行うアプローチです

前のセクションで学んだ FIDO2 とパスキーは、パスワードレス認証の代表的な実装です

パスワードレス認証は、パスワードの漏洩という問題自体を排除することで、フィッシングやクレデンシャルスタッフィングに対する根本的な対策となります

### ゼロトラストの考え方

従来のセキュリティモデルでは、「社内ネットワークは信頼できる」「一度認証すれば信頼できる」という前提がありました

<strong>ゼロトラスト</strong>（Zero Trust）は、この前提を否定する考え方です

ゼロトラストの原則は「<strong>何も信頼せず、常に検証する</strong>」（Never trust, always verify）です

| 従来のモデル                                     | ゼロトラスト                               |
| ------------------------------------------------ | ------------------------------------------ |
| 社内ネットワークからのアクセスは信頼する         | ネットワークの場所に関係なく検証する       |
| 一度認証すればセッション中は信頼する             | アクセスのたびにリスクを評価する           |
| VPN で社内に接続すれば全リソースにアクセスできる | リソースごとに最小限のアクセス権を付与する |

ゼロトラストにおいて、認証は<strong>一度きりのイベントではなく、継続的なプロセス</strong>です

ユーザーの行動パターンが通常と異なる場合（たとえば、普段とは異なる国からのアクセスや、通常アクセスしないリソースへの要求など）、追加の認証を要求することがあります

ゼロトラストの考え方は、このトピックで学んだ認証と認可の仕組みを基盤としています

「誰がアクセスしているか」（認証）と「何にアクセスできるか」（認可）を、あらゆるアクセスに対して常に検証する、という考え方です

次のトピック [05-access-control](./05-access-control.md) では、「何にアクセスできるか」を管理する<strong>アクセス制御モデル</strong>を詳しく学びます

---

## 次のトピックへ

このトピックでは、以下のことを学びました

- 認証は「あなたは誰か」を確認するプロセスであり、認可は「あなたは何ができるか」を決定するプロセスである
- パスワードはハッシュ化とソルトで保護し、鍵導出関数（bcrypt、Argon2）で計算コストを高めることでブルートフォース攻撃に対抗する
- セッションベース認証は Cookie とセッション ID でログイン状態を維持するが、サーバー側の状態管理が課題となる
- JWT はトークン自体にユーザー情報と署名を含むステートレスな認証方式であり、完全性と真正性を保証する
- OAuth 2.0 はパスワードを共有せずに権限を委譲するフレームワークであり、スコープで最小権限の原則を実現する
- 多要素認証は知識・所持・生体の異なる種類の要素を組み合わせて安全性を高める
- FIDO2 とパスキーは公開鍵暗号を応用したフィッシング耐性のある認証方式である
- ゼロトラストは「何も信頼せず、常に検証する」原則であり、認証と認可を継続的に行う

しかし、ここで重要な疑問が残ります

認証で<strong>「誰か」</strong>は確認できるようになりましたが、その人が<strong>「何をできるか」</strong>をどのように体系的に管理するのでしょうか？

OAuth のスコープはアクセス制御の一例ですが、組織全体のアクセス権限はどのようなモデルで管理されているのでしょうか？

RBAC（役割ベースアクセス制御）や ABAC（属性ベースアクセス制御）とは、どのような仕組みでしょうか？

OS レベルでは、プロセスのアクセス権限はどのように制御されているのでしょうか？

次のトピック [05-access-control](./05-access-control.md) では、<strong>アクセス制御モデル</strong>の仕組みを学びます

---

## 用語集

| 用語                                                | 説明                                                                                                               |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| 認証（Authentication）                              | 「あなたは誰か」を確認するプロセス。パスワード、生体情報、証明書などの手段で身元を検証する                         |
| 認可（Authorization）                               | 「あなたは何ができるか」を決定するプロセス。認証の後に行われ、アクセス権限を付与する                               |
| 平文（Plaintext）                                   | 暗号化やハッシュ化されていないそのままのデータ。パスワードを平文で保存することはセキュリティ上の重大なリスクとなる |
| パスワードハッシュ                                  | パスワードをハッシュ関数で一方向に変換した値。データベースにはハッシュ値のみを保存し、元のパスワードは保持しない   |
| ソルト（Salt）                                      | パスワードをハッシュ化する前に付加するランダムな文字列。同じパスワードでも異なるハッシュ値を生成する               |
| レインボーテーブル（Rainbow Table）                 | よく使われるパスワードとそのハッシュ値をあらかじめ計算した一覧。ソルトの使用で対策される                           |
| 鍵導出関数（Key Derivation Function）               | 計算コストを意図的に高くすることでブルートフォース攻撃を困難にするハッシュ関数。bcrypt や Argon2 が代表的          |
| bcrypt                                              | 計算コストを調整可能な鍵導出関数。内部でハッシュ計算を繰り返すことで意図的に遅くする                               |
| Argon2                                              | 計算コストに加えてメモリ使用量も調整可能な鍵導出関数。GPU を使った並列攻撃にも対抗できる                           |
| ストレッチング（Stretching）                        | ハッシュ計算を意図的に繰り返すことで計算コストを高める手法                                                         |
| ブルートフォース攻撃（Brute Force Attack）          | パスワードの候補を片端から試行する総当たり攻撃                                                                     |
| ステートレス（Stateless）                           | サーバーがクライアントの状態を保持しない設計。HTTP プロトコルの基本的な性質                                        |
| セッション（Session）                               | ユーザーのログイン状態をサーバー側で管理する仕組み。セッション ID で識別する                                       |
| セッション ID                                       | セッションを一意に識別するランダムな文字列。Cookie に格納されてブラウザとサーバー間でやり取りされる                |
| Cookie                                              | RFC 6265 で定義された、ブラウザとサーバーの間で小さなデータをやり取りする仕組み                                    |
| Set-Cookie ヘッダ                                   | サーバーがブラウザに Cookie を送信するために使用する HTTP レスポンスヘッダ                                         |
| Secure 属性                                         | HTTPS 接続でのみ Cookie を送信する Cookie の属性                                                                   |
| HttpOnly 属性                                       | JavaScript からのアクセスを禁止する Cookie の属性。XSS によるセッション ID の窃取を防ぐ                            |
| SameSite 属性                                       | 異なるサイトからのリクエストに Cookie を含めるかを制御する属性。CSRF 攻撃の防御に関わる                            |
| セッション固定攻撃（Session Fixation）              | 攻撃者が事前に知っているセッション ID をユーザーに使わせてセッションを乗っ取る攻撃                                 |
| セッションハイジャック（Session Hijacking）         | セッション ID を盗み取り、そのユーザーになりすます攻撃                                                             |
| トークン（Token）                                   | 認証や認可の情報を表す文字列。セッション ID とは異なり、トークン自体に情報を含むことができる                       |
| JWT（JSON Web Token）                               | RFC 7519 で定義された、認証情報をJSON 形式で表現するトークン。ヘッダー、ペイロード、署名の 3 部で構成される        |
| クレーム（Claim）                                   | JWT のペイロードに含まれる情報の単位。iss（発行者）、sub（主体）、exp（有効期限）などの標準クレームがある          |
| アクセストークン（Access Token）                    | リソースへのアクセスに使われる短命なトークン                                                                       |
| リフレッシュトークン（Refresh Token）               | 新しいアクセストークンを取得するための長命なトークン                                                               |
| Bearer トークン                                     | トークンを持っているだけでアクセスが許可されるトークン。Authorization ヘッダで送信される                           |
| OAuth 2.0                                           | RFC 6749 で定義された認可フレームワーク。パスワードを共有せずに限定された権限を安全に委譲する                      |
| リソースオーナー（Resource Owner）                  | 保護されたリソースの所有者。通常はユーザー自身                                                                     |
| クライアント（Client）                              | リソースオーナーの代わりにリソースにアクセスするアプリケーション                                                   |
| 認可サーバー（Authorization Server）                | リソースオーナーの認証と認可を行い、アクセストークンを発行するサーバー                                             |
| リソースサーバー（Resource Server）                 | 保護されたリソースをホストし、アクセストークンを検証してリソースを提供するサーバー                                 |
| 認可コード（Authorization Code）                    | 認可コードフローで使われる短命で 1 回限りのコード。アクセストークンと交換される                                    |
| 認可コードフロー（Authorization Code Flow）         | OAuth 2.0 の最も一般的なフロー。認可コードを介してアクセストークンを安全に取得する                                 |
| PKCE（Proof Key for Code Exchange）                 | 認可コードの横取り攻撃を防ぐ拡張。コードベリファイアとコードチャレンジのペアで保護する                             |
| スコープ（Scope）                                   | アクセストークンの権限範囲を制限する仕組み。最小権限の原則を実現する                                               |
| リダイレクト URI                                    | 認可コードフローで、認可サーバーがユーザーをクライアントに戻す際の URI                                             |
| 最小権限の原則（Principle of Least Privilege）      | 必要最小限の権限だけを付与するセキュリティの原則                                                                   |
| 多要素認証（MFA：Multi-Factor Authentication）      | 知識・所持・生体の異なる種類の認証要素を 2 つ以上組み合わせる認証方式                                              |
| 知識要素（Knowledge Factor）                        | 本人だけが知っている情報による認証要素。パスワード、PIN、秘密の質問など                                            |
| 所持要素（Possession Factor）                       | 本人だけが持っている物理的なものによる認証要素。スマートフォン、セキュリティキーなど                               |
| 生体要素（Inherence Factor）                        | 本人の身体的特徴による認証要素。指紋、顔認証、虹彩認証など                                                         |
| ワンタイムパスワード（OTP：One-Time Password）      | 1 回限り有効なパスワード。使用後または一定時間後に無効になる                                                       |
| TOTP（Time-based One-Time Password）                | 共有秘密と現在時刻から HMAC を使って生成される時間ベースのワンタイムパスワード                                     |
| FIDO2                                               | パスワードに依存しない認証の標準。公開鍵暗号を使用し、秘密鍵はデバイスに保持される                                 |
| パスキー（Passkey）                                 | FIDO2 の仕組みを使いやすくした実装。パスワードレスでフィッシング耐性のある認証を実現する                           |
| WebAuthn（Web Authentication）                      | FIDO2 の Web ブラウザ向け API。ブラウザを通じて FIDO2 認証を行うための標準                                         |
| フィッシング（Phishing）                            | 正規のサイトに見せかけた偽サイトにユーザーを誘導し、認証情報を盗む攻撃                                             |
| クレデンシャルスタッフィング（Credential Stuffing） | 漏洩したユーザー名とパスワードの組み合わせを別のサービスに大量試行する攻撃                                         |
| パスワードレス認証（Passwordless Authentication）   | パスワードを使わずに認証を行うアプローチ。FIDO2 やパスキーが代表的                                                 |
| ゼロトラスト（Zero Trust）                          | 「何も信頼せず、常に検証する」というセキュリティモデル。ネットワークの場所に関係なくアクセスを検証する             |
| OpenID Connect                                      | OAuth 2.0 を拡張して認証機能を追加したプロトコル。ID トークンによるユーザーの身元確認を行う                        |
| ID トークン                                         | OpenID Connect で発行される JWT 形式のトークン。ユーザーの身元情報を含む                                           |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>認証・セッション管理</strong>

- [RFC 6265 - HTTP State Management Mechanism](https://datatracker.ietf.org/doc/html/rfc6265)
  - HTTP Cookie の仕様（Set-Cookie ヘッダ、Cookie 属性、セキュリティ考慮事項）

<strong>トークン</strong>

- [RFC 7519 - JSON Web Token (JWT)](https://datatracker.ietf.org/doc/html/rfc7519)
  - JWT の仕様（トークン構造、標準クレーム、署名アルゴリズム）

<strong>OAuth</strong>

- [RFC 6749 - The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
  - OAuth 2.0 の仕様（認可フロー、アクセストークン、スコープ、クライアント認証）
