<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 03-certificate：証明書と PKI（信頼の連鎖）

## はじめに

前のトピック [02-tls](./02-tls.md) では、TLS の「なぜ安全か」という原理を学びました

- TLS 1.3 は対称暗号、非対称暗号、ハッシュ関数、鍵交換、AEAD を組み合わせて安全な通信を実現している
- ハンドシェイクの各ステップには明確なセキュリティ上の目的があり、1 往復で安全な鍵共有が可能である
- HKDF による鍵導出で、1 つの共有秘密から用途ごとに独立した鍵が生成される
- 前方秘匿性はエフェメラル鍵の使用で実現され、TLS 1.3 では必須化された
- 0-RTT はリプレイ攻撃のリスクと前方秘匿性の欠如を伴う
- ダウングレード攻撃はセンチネル値と暗号スイートの制限で防御される

02-tls の最後に、こう問いかけました

<strong>TLS ハンドシェイクではサーバーが証明書を提示しますが、なぜその証明書を信頼できるのでしょうか？</strong>

証明書を発行する認証局は、どのように信頼されるのでしょうか？

もし認証局が不正な証明書を発行してしまったら、どうなるのでしょうか？

証明書の有効期限が切れたり、秘密鍵が漏洩した場合、どのような仕組みで証明書を失効させるのでしょうか？

このトピックでは、<strong>証明書と PKI（Public Key Infrastructure）</strong>の仕組みを学びます

TLS ハンドシェイクで提示される証明書が「なぜ信頼できるか」を理解し、その信頼を支える基盤全体を俯瞰します

---

## 日常の例え

証明書と PKI の仕組みを、日常の例えで見てみましょう

<strong>証明書 = パスポート</strong>

パスポートには、あなたの名前、顔写真、国籍などの身元情報が記載されています

パスポートを発行するのは政府であり、政府の印章によってその内容が保証されています

パスポートを見せれば、相手は「この人は本人である」と確認できます

なぜなら、相手は政府という<strong>信頼された機関</strong>が発行したことを知っているからです

デジタル証明書も同じで、サーバーの公開鍵と身元情報を含み、<strong>認証局</strong>（CA）という信頼された機関がデジタル署名で保証しています

<strong>信頼の連鎖 = 紹介状のリレー</strong>

あなたは友人 A を信頼しているとします

友人 A は「B さんは信頼できる人です」と紹介状を書きました

あなたは B さんに会ったことがなくても、友人 A が保証しているので B さんを信頼できます

PKI の<strong>信頼の連鎖</strong>も同じで、OS やブラウザが信頼するルート CA が中間 CA を保証し、中間 CA がサーバーの証明書を保証します

<strong>証明書の失効 = クレジットカードの利用停止</strong>

クレジットカードを紛失したら、カード会社に連絡して利用を停止します

お店はカードを受け付ける前に、そのカードが現在も有効かどうかを確認する必要があります

証明書の<strong>失効</strong>も同じで、秘密鍵が漏洩した場合は認証局に連絡して証明書を無効化し、ブラウザはその証明書がまだ有効かどうかを確認します

<strong>Certificate Transparency = 公開台帳</strong>

もし発行されたすべてのパスポートが、誰でも閲覧できる公開台帳に記録されていたらどうでしょうか

偽造パスポートが発行されても、台帳を確認すれば不正を発見できます

<strong>Certificate Transparency</strong> も同じで、発行されたすべての証明書を公開ログに記録し、不正な証明書の発行を誰でも監視できるようにしています

---

## このページで学ぶこと

このページでは、以下の概念を学びます

<strong>証明書の必要性</strong>

- <strong>なぜ公開鍵だけでは不十分か</strong>
  - 公開鍵の所有者を証明する仕組みの必要性
- <strong>X.509 証明書の構造</strong>
  - 証明書に含まれる情報とその役割

<strong>PKI（公開鍵基盤）</strong>

- <strong>認証局（CA）の役割</strong>
  - 証明書を発行し、信頼を保証する仕組み
- <strong>信頼の連鎖</strong>
  - ルート CA、中間 CA、エンドエンティティ証明書の階層構造

<strong>証明書の検証と失効</strong>

- <strong>証明書の検証プロセス</strong>
  - ブラウザが証明書を信頼するまでの流れ
- <strong>証明書の失効</strong>
  - CRL と OCSP による失効確認の仕組み

<strong>信頼モデルの課題と進化</strong>

- <strong>Certificate Transparency</strong>
  - 認証局の不正発行を検出する公開ログの仕組み
- <strong>証明書の自動化</strong>
  - Let's Encrypt と証明書管理の現代的なアプローチ

---

## 目次

1. [なぜ証明書が必要か](#なぜ証明書が必要か)
2. [X.509 証明書](#x509-証明書)
3. [PKI（Public Key Infrastructure）](#pkipublic-key-infrastructure)
4. [証明書の検証プロセス](#証明書の検証プロセス)
5. [証明書の失効](#証明書の失効)
6. [Certificate Transparency](#certificate-transparency)
7. [証明書の自動化と現代の課題](#証明書の自動化と現代の課題)
8. [次のトピックへ](#次のトピックへ)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## なぜ証明書が必要か

### TLS ハンドシェイクの疑問

[02-tls](./02-tls.md) で学んだように、TLS ハンドシェイクではサーバーが公開鍵を含む証明書を提示します

クライアントはこの公開鍵を使って Diffie-Hellman 鍵交換を行い、安全な通信を確立します

さらに、サーバーは CertificateVerify メッセージでデジタル署名を送り、「この公開鍵に対応する秘密鍵を持っている」ことを証明します

しかし、ここで疑問が生じます

「この公開鍵に対応する秘密鍵を持っている」ことは証明できても、<strong>「この公開鍵が本当に example.com のものである」ことは証明できません</strong>

### 公開鍵だけでは信頼できない

[01-cryptography](./01-cryptography.md) で学んだように、公開鍵と秘密鍵のペアは誰でも自由に生成できます

つまり、攻撃者も鍵ペアを生成して「この公開鍵は example.com のものです」と主張できてしまいます

公開鍵だけでは、以下の 2 つのことしか保証できません

- この公開鍵と秘密鍵は数学的に対応している
- 送信者は秘密鍵を持っている（デジタル署名で証明）

公開鍵だけでは保証できないのは、次のことです

- <strong>この公開鍵が「誰のもの」であるか</strong>

公開鍵と身元情報を結びつけ、信頼された第三者が「この公開鍵は確かに example.com のものです」と保証する仕組みが必要です

それが<strong>証明書</strong>です

### 中間者攻撃と証明書の関係

証明書がなければ、中間者攻撃（MITM）で公開鍵を差し替えることができてしまいます

```
  正常な通信：
  ┌──────────┐                                  ┌──────────┐
  │ クライアント │──── サーバーの公開鍵を取得 ────→│  サーバー  │
  └──────────┘                                  └──────────┘

  中間者攻撃（公開鍵の差し替え）：
  ┌──────────┐          ┌────────┐              ┌──────────┐
  │ クライアント │── 要求 →│  攻撃者  │── 要求 ────→│  サーバー  │
  └──────────┘          └────────┘              └──────────┘
                     攻撃者の公開鍵を        サーバーの公開鍵を
                     クライアントに送信       攻撃者が受け取る
```

攻撃者はサーバーとクライアントの間に割り込み、自分の公開鍵をクライアントに渡します

クライアントは攻撃者の公開鍵をサーバーのものだと信じて通信を開始し、攻撃者はすべての通信を傍受できます

証明書は、この攻撃を防ぐために存在します

証明書は<strong>公開鍵と身元情報を結びつけ</strong>、信頼された認証局のデジタル署名で「この公開鍵は確かに example.com のものである」と保証します

攻撃者が自分の公開鍵を差し替えても、認証局の署名がないため、クライアントは偽物だと判断できます

これは [01-cryptography](./01-cryptography.md) で学んだ<strong>真正性</strong>（Authenticity）の具体的な実現手段です

---

## X.509 証明書

### X.509 証明書とは

<strong>X.509</strong> は、デジタル証明書の標準形式です

ITU-T が定義し、RFC 5280 で HTTPS や TLS での使用方法が規定されています

インターネット上で使われるほぼすべての証明書が X.509 形式であり、TLS ハンドシェイクでサーバーが提示するのもこの形式の証明書です

パスポートの例えに戻ると、X.509 は「パスポートの書式」にあたります

どの国のパスポートも同じ項目（名前、顔写真、国籍、有効期限など）を含んでいるように、X.509 証明書も標準化された項目を含んでいます

### 証明書に含まれる情報

X.509 v3 証明書には、以下の情報が含まれています

| フィールド           | 内容                                                      |
| -------------------- | --------------------------------------------------------- |
| Subject（主体者）    | 証明書の発行対象（ドメイン名や組織名）                    |
| Issuer（発行者）     | 証明書を発行した認証局の名前                              |
| Public Key（公開鍵） | 主体者の公開鍵とそのアルゴリズム                          |
| Serial Number        | 認証局が発行した証明書を一意に識別する番号                |
| Validity（有効期間） | 証明書の有効開始日（Not Before）と有効終了日（Not After） |
| Signature Algorithm  | 認証局が証明書に署名するために使ったアルゴリズム          |
| Digital Signature    | 認証局が上記のすべての情報に対して行ったデジタル署名      |
| Extensions（拡張）   | SAN、Key Usage、Basic Constraints などの追加情報          |

特に重要な拡張フィールドが <strong>SAN</strong>（Subject Alternative Name）です

SAN は、1 つの証明書で複数のドメイン名を指定できる拡張フィールドです

たとえば、1 つの証明書で `example.com` と `www.example.com` の両方を保護できます

現在のブラウザは、証明書の Subject フィールドではなく SAN フィールドを参照してドメイン名を検証します

### デジタル署名による保証

証明書の信頼性は、認証局の<strong>デジタル署名</strong>で保証されています

[01-cryptography](./01-cryptography.md) で学んだデジタル署名の仕組みを思い出しましょう

```
  証明書の発行プロセス：

  ┌──────────────────────────────┐
  │ 証明書の内容                   │
  │ ・Subject: example.com        │
  │ ・Public Key: サーバーの公開鍵  │
  │ ・Validity: 2025/01 - 2025/12 │
  │ ・Issuer: Example CA          │
  └──────────────┬───────────────┘
                 │
                 ▼ ハッシュ化
          ┌────────────┐
          │  ハッシュ値   │
          └──────┬─────┘
                 │
                 ▼ CA の秘密鍵で署名
          ┌────────────┐
          │ デジタル署名  │──→ 証明書に添付
          └────────────┘
```

認証局は、証明書の内容をハッシュ化し、自身の秘密鍵で署名します

証明書を受け取った側は、認証局の公開鍵を使って署名を検証できます

署名の検証に成功すれば、次の 2 つのことが保証されます

- 証明書の内容は<strong>改ざんされていない</strong>（完全性）
- 証明書は確かに<strong>認証局が発行した</strong>（真正性）

### 証明書の有効期間

証明書には有効期間が設定されており、永久に使えるわけではありません

有効期間を設ける理由は 2 つあります

<strong>秘密鍵の漏洩リスクを限定する</strong>：秘密鍵が漏洩しても、証明書の有効期限が切れれば自動的に使えなくなります

<strong>定期的な身元確認を促す</strong>：証明書の更新時に、認証局がドメインの管理権限を再確認します

歴史的に、証明書の有効期間は短縮されてきました

かつては 5 年有効な証明書もありましたが、現在は最長 398 日（約 13 か月）に制限されています

---

## PKI（Public Key Infrastructure）

### PKI とは

<strong>PKI</strong>（Public Key Infrastructure、公開鍵基盤）は、デジタル証明書の発行、管理、検証、失効を行うための<strong>基盤全体</strong>を指します

PKI は単一の技術ではなく、以下の要素で構成されるシステムです

- <strong>認証局</strong>（CA）：証明書を発行する機関
- <strong>トラストストア</strong>：信頼されたルート CA の一覧を管理する仕組み
- <strong>証明書チェーン</strong>：信頼の連鎖を構成する階層構造
- <strong>失効管理</strong>：無効になった証明書を管理する仕組み（CRL、OCSP）

パスポートの例えで言えば、PKI は「パスポートの発行体制全体」にあたります

パスポートの書式だけでなく、発行する政府機関、パスポートの真偽を確認する仕組み、紛失時の無効化手続きまでを含む、信頼のインフラ全体です

### 認証局（CA）の役割

<strong>認証局</strong>（Certificate Authority）は、証明書を発行する信頼された機関です

認証局の最も重要な役割は、証明書の申請者が本当にそのドメインや組織の管理者であるかを<strong>確認すること</strong>です

確認の厳密さに応じて、3 つの検証レベルがあります

| 検証レベル                    | 確認内容                          | 信頼度 |
| ----------------------------- | --------------------------------- | ------ |
| DV（Domain Validation）       | ドメインの管理権限のみ            | 基本   |
| OV（Organization Validation） | ドメイン + 組織の実在性           | 中     |
| EV（Extended Validation）     | ドメイン + 組織の詳細な実在性確認 | 高     |

<strong>DV 証明書</strong>は最も一般的で、ドメインの管理権限を持っていることだけを確認します

たとえば、申請者が指定されたファイルを Web サーバーに配置できること、または DNS レコードを設定できることで確認します

Let's Encrypt が発行するのは DV 証明書です

<strong>OV 証明書</strong>は、ドメインの管理権限に加えて、組織が実在することを確認します

<strong>EV 証明書</strong>は最も厳格な検証を行い、組織の法的実在性、住所、申請者の権限まで確認します

いずれの検証レベルでも、暗号化の強度に違いはありません

違いは「身元確認の厳密さ」です

### 信頼の連鎖（Certificate Chain）

PKI の中核にあるのが<strong>信頼の連鎖</strong>（Certificate Chain）です

```
  ┌─────────────────────────────────────────┐
  │ ルート CA 証明書（自己署名）               │
  │ ・自分自身の秘密鍵で署名                    │
  │ ・OS やブラウザのトラストストアに格納        │
  └────────────────────┬────────────────────┘
                       │ ルート CA の秘密鍵で署名
                       ▼
  ┌─────────────────────────────────────────┐
  │ 中間 CA 証明書                             │
  │ ・ルート CA が身元を確認して発行             │
  │ ・エンドエンティティ証明書の発行を担当       │
  └────────────────────┬────────────────────┘
                       │ 中間 CA の秘密鍵で署名
                       ▼
  ┌─────────────────────────────────────────┐
  │ エンドエンティティ証明書（サーバー証明書）   │
  │ ・example.com の公開鍵と身元情報を含む       │
  │ ・TLS ハンドシェイクで提示される              │
  └─────────────────────────────────────────┘
```

信頼の連鎖は下から上に向かって検証されます

1. サーバー証明書は、中間 CA の署名で保証されている
2. 中間 CA 証明書は、ルート CA の署名で保証されている
3. ルート CA 証明書は、OS やブラウザのトラストストアにあらかじめ格納されている

最終的に「なぜ信頼できるか」の答えは、<strong>OS やブラウザがルート CA を信頼しているから</strong>です

### ルート CA と中間 CA

<strong>ルート CA</strong> は信頼の連鎖の頂点に位置する認証局です

ルート CA 証明書は<strong>自己署名証明書</strong>であり、自分自身の秘密鍵で自分の証明書に署名しています

ルート CA 証明書は OS やブラウザにあらかじめ組み込まれており、これが信頼の起点（トラストアンカー）になります

<strong>中間 CA</strong> はルート CA と エンドエンティティ（サーバー）の間に位置する認証局です

中間 CA が存在する最大の理由は、<strong>ルート CA の秘密鍵を保護する</strong>ためです

| 特性           | ルート CA                | 中間 CA                                |
| -------------- | ------------------------ | -------------------------------------- |
| 署名           | 自己署名                 | ルート CA の署名を受ける               |
| 秘密鍵の保管   | オフラインの厳重な保管   | オンラインで運用                       |
| 証明書の発行   | 中間 CA 証明書のみを発行 | エンドエンティティ証明書を発行         |
| 侵害された場合 | 信頼モデル全体に影響     | 中間 CA 証明書の失効で影響を限定できる |

ルート CA の秘密鍵が漏洩すると、そのルート CA が保証するすべての証明書が信頼できなくなります

そのため、ルート CA の秘密鍵はオフラインの物理的に隔離された環境に保管され、中間 CA 証明書の発行時にのみ使用されます

日常的なサーバー証明書の発行は、中間 CA が担当します

### なぜ階層構造なのか

階層構造には 3 つのメリットがあります

<strong>侵害の隔離</strong>：中間 CA が侵害された場合、その中間 CA 証明書を失効させれば影響を限定でき、ルート CA を失効させる必要はありません

<strong>権限の委譲</strong>：ルート CA がすべての証明書を直接発行するのは現実的ではないため、複数の中間 CA に発行権限を委譲することで証明書の大量発行を実現しています

<strong>スケーラビリティ</strong>：地域や用途ごとに中間 CA を設けることで、異なるポリシーや検証レベルで証明書を発行できます

---

## 証明書の検証プロセス

### ブラウザはどう証明書を検証するか

ブラウザが HTTPS サイトにアクセスすると、TLS ハンドシェイクの中でサーバーから証明書を受け取ります

ブラウザは以下の手順で証明書を検証します

1. サーバーからエンドエンティティ証明書と中間 CA 証明書を受け取る
2. 証明書チェーンを構築する（エンドエンティティ → 中間 CA → ルート CA）
3. チェーン内の各証明書を検証する
4. ルート CA 証明書がトラストストアに含まれているか確認する
5. すべての検証に成功したら、接続を確立する

### チェーンの検証

チェーン内の各証明書に対して、以下の検証を行います

```
  ┌────────────────────────────────────────────────────┐
  │ 証明書チェーンの検証                                  │
  │                                                      │
  │  エンドエンティティ証明書                              │
  │    ├─ ① 署名の検証（中間 CA の公開鍵で検証）          │
  │    ├─ ② 有効期間の確認（期限内であるか）              │
  │    ├─ ③ ドメイン名の一致（SAN と一致するか）          │
  │    └─ ④ 失効状態の確認（OCSP / CRL）                 │
  │                                                      │
  │  中間 CA 証明書                                       │
  │    ├─ ① 署名の検証（ルート CA の公開鍵で検証）        │
  │    ├─ ② 有効期間の確認                               │
  │    ├─ ③ Basic Constraints の確認（CA フラグが真）     │
  │    └─ ④ 失効状態の確認                               │
  │                                                      │
  │  ルート CA 証明書                                     │
  │    └─ トラストストアに存在するか確認                   │
  └────────────────────────────────────────────────────┘
```

<strong>署名の検証</strong>：各証明書のデジタル署名を、発行者（上位 CA）の公開鍵で検証します

署名が正しければ、証明書が改ざんされていないこと、確かにその CA が発行したことが確認できます

<strong>有効期間の確認</strong>：現在の日時が、証明書の Not Before と Not After の間にあるかを確認します

<strong>ドメイン名の一致</strong>：エンドエンティティ証明書の SAN フィールドが、アクセスしようとしているドメイン名と一致するかを確認します

<strong>Basic Constraints</strong>：中間 CA 証明書には、CA として機能できることを示す Basic Constraints 拡張が含まれている必要があります

これにより、通常のサーバー証明書が不正に他の証明書を発行することを防ぎます

### トラストストア

<strong>トラストストア</strong>は、信頼されたルート CA 証明書の一覧です

OS やブラウザはそれぞれ独自のトラストストアを管理しており、信頼の起点として機能します

| 管理者    | トラストストア         | 含まれるルート CA 数 |
| --------- | ---------------------- | -------------------- |
| Apple     | Apple Root Certificate | 約 150               |
| Microsoft | Microsoft Root Program | 約 400               |
| Mozilla   | Mozilla Root Store     | 約 150               |
| Google    | Chrome Root Store      | 約 150               |

ルート CA がトラストストアに含まれるには、厳格な審査基準を満たす必要があります

たとえば、Mozilla Root Store Policy では、CA の運営体制、監査報告書、技術的な要件が詳細に定められています

トラストストアの管理者（OS ベンダーやブラウザベンダー）は、不適切な CA をトラストストアから削除する権限を持っています

この仕組みにより、信頼は「技術的な正しさ」だけでなく「運営の適切さ」にも依存しています

### 検証が失敗するケース

証明書の検証が失敗する主なケースは以下のとおりです

| 失敗の原因         | 状況                                                       |
| ------------------ | ---------------------------------------------------------- |
| 有効期限切れ       | 証明書の有効期間を過ぎている                               |
| 不明な認証局       | 発行元の CA がトラストストアに含まれていない               |
| ドメイン名の不一致 | 証明書の SAN がアクセス先のドメインと一致しない            |
| 証明書の失効       | 証明書が CRL や OCSP で失効と報告されている                |
| 自己署名証明書     | 信頼されたルート CA への連鎖がない                         |
| チェーンの不完全   | サーバーが中間 CA 証明書を送信せず、チェーンを構築できない |

検証に失敗すると、ブラウザはセキュリティ警告を表示し、ユーザーに接続のリスクを通知します

---

## 証明書の失効

### なぜ失効が必要か

証明書には有効期間がありますが、有効期間内であっても証明書を無効にしなければならない場合があります

- <strong>秘密鍵の漏洩</strong>：サーバーの秘密鍵が攻撃者に盗まれた場合、攻撃者はその鍵を使ってサーバーになりすますことができます
- <strong>認証局の誤発行</strong>：認証局が身元確認を適切に行わずに証明書を発行してしまった場合
- <strong>組織の変更</strong>：ドメインの所有者が変わった場合

失効の仕組みがなければ、漏洩した秘密鍵に対応する証明書が有効期限まで使われ続け、攻撃者がなりすましを続けることができてしまいます

### CRL（Certificate Revocation List）

<strong>CRL</strong>（Certificate Revocation List、証明書失効リスト）は、認証局が公開する「失効した証明書の一覧」です

RFC 5280 で定義されており、証明書の失効確認の最も基本的な方法です

仕組みはシンプルです

1. 認証局が失効した証明書のシリアル番号を CRL に追加する
2. CRL を定期的に公開する
3. クライアントは CRL をダウンロードし、対象の証明書が含まれていないかを確認する

CRL にはいくつかの課題があります

<strong>サイズの問題</strong>：大規模な認証局の CRL は数 MB に達することがあり、ダウンロードに時間がかかります

<strong>更新頻度の問題</strong>：CRL は定期的にしか更新されないため、失効直後の証明書がまだ CRL に反映されていない場合があります

### OCSP（Online Certificate Status Protocol）

<strong>OCSP</strong>（Online Certificate Status Protocol）は、証明書の失効状態を<strong>リアルタイム</strong>で問い合わせるプロトコルです

RFC 6960 で定義されています

```
  OCSP の仕組み：

  ┌──────────┐                                  ┌──────────────┐
  │ クライアント │── この証明書はまだ有効？ ───→│ OCSP レスポンダ │
  └──────────┘                                  └──────┬───────┘
       ▲                                               │
       │                                               ▼
       │                                        ┌────────────┐
       └───── good / revoked / unknown ────────│ 署名付き応答  │
                                                └────────────┘
```

クライアントは証明書のシリアル番号を OCSP レスポンダに送信し、レスポンダは 3 つの状態のいずれかを返します

| 応答状態 | 意味                                       |
| -------- | ------------------------------------------ |
| good     | 証明書は有効（失効していない）             |
| revoked  | 証明書は失効済み                           |
| unknown  | レスポンダがその証明書の情報を持っていない |

OCSP は CRL の課題を解決しますが、新たな課題を生みます

<strong>プライバシーの問題</strong>：クライアントが OCSP レスポンダに問い合わせるたびに、「どのサイトにアクセスしようとしているか」が認証局に伝わります

<strong>可用性の問題</strong>：OCSP レスポンダがダウンしていると、証明書の有効性を確認できません

### OCSP Stapling

<strong>OCSP Stapling</strong> は、OCSP のプライバシーと可用性の問題を解決する仕組みです

```
  通常の OCSP：
  ┌──────────┐                ┌────────┐              ┌──────────────┐
  │ クライアント │── TLS 接続 →│ サーバー │              │ OCSP レスポンダ │
  └──────────┘              └────────┘              └──────────────┘
       │                                                    ▲
       └──── この証明書は有効？ ────────────────────────────┘
             （プライバシーの漏洩）

  OCSP Stapling：
  ┌──────────┐                ┌────────┐              ┌──────────────┐
  │ クライアント │── TLS 接続 →│ サーバー │── 定期取得 →│ OCSP レスポンダ │
  └──────────┘              └────────┘              └──────────────┘
       ▲                         │
       └── 証明書 + OCSP 応答 ──┘
          （サーバーが添付）
```

OCSP Stapling では、<strong>サーバー自身</strong>が定期的に OCSP レスポンダから自分の証明書の状態を取得します

サーバーは TLS ハンドシェイク時に、証明書と一緒にこの OCSP 応答を「ステープル」（添付）してクライアントに送ります

OCSP 応答には OCSP レスポンダのデジタル署名が含まれているため、サーバーが応答を改ざんすることはできません

この方式には 2 つのメリットがあります

- クライアントが直接 OCSP レスポンダに問い合わせないため、<strong>プライバシーが保護</strong>される
- OCSP レスポンダの可用性に依存しないため、<strong>信頼性が向上</strong>する

### 失効確認の課題

証明書の失効確認には、根本的な課題があります

<strong>Soft-fail 問題</strong>：ほとんどのブラウザは、CRL のダウンロードや OCSP の問い合わせに失敗した場合、エラーにせず通信を続行します（Soft-fail）

これは可用性を優先した判断ですが、セキュリティ上のリスクを生みます

攻撃者が OCSP レスポンダへの通信をブロックすれば、失効した証明書でもブラウザは受け入れてしまいます

この課題に対する現代のアプローチは、<strong>証明書の有効期間を短くする</strong>ことです

有効期間が 90 日であれば、たとえ失効確認が完全でなくても、漏洩の影響は最大 90 日間に限定されます

---

## Certificate Transparency

### 認証局を誰が監視するか

PKI の信頼モデルは、認証局が正しく運営されていることを前提としています

しかし、認証局自身が不正な証明書を発行してしまったら、どうなるでしょうか

認証局は数百存在し、どの認証局もあらゆるドメインの証明書を発行できます

つまり、1 つの認証局が侵害されるだけで、任意のドメインに対する偽の証明書が発行される可能性があります

<strong>Certificate Transparency</strong>（CT）は、この問題に対する解決策です

### Certificate Transparency とは

<strong>Certificate Transparency</strong> は、発行されたすべての証明書を<strong>公開ログ</strong>に記録し、不正な発行を誰でも検出できるようにする仕組みです

RFC 6962 で定義されています

CT の基本的な考え方はシンプルです

<strong>すべての証明書を公開し、隠し事をなくす</strong>

認証局が証明書を発行するとき、その証明書を CT ログに登録します

CT ログは追記専用（append-only）の公開データベースで、一度記録された証明書は削除できません

ドメインの管理者は CT ログを監視することで、自分のドメインに対して不正な証明書が発行されていないかを確認できます

### CT ログの仕組み

CT は 3 つの役割で構成されます

| 役割           | 担当者                | 責務                                                |
| -------------- | --------------------- | --------------------------------------------------- |
| 提出者         | 認証局                | 証明書を CT ログに登録する                          |
| ログオペレータ | Google、Cloudflare 等 | CT ログを運用し、記録された証明書の完全性を保証する |
| モニター       | ドメイン管理者、企業  | CT ログを監視し、不正な証明書の発行を検出する       |

証明書が CT ログに登録されると、ログは <strong>SCT</strong>（Signed Certificate Timestamp）を返します

SCT は「この証明書は確かにログに記録された」という証明です

現在の主要なブラウザ（特に Chrome）は、証明書に SCT が含まれていることを<strong>必須</strong>としています

SCT のない証明書は、正規の認証局が発行したものであっても、ブラウザに信頼されません

CT ログの内部では、<strong>マークル木</strong>（Merkle Tree）と呼ばれるデータ構造が使われています

マークル木は [01-cryptography](./01-cryptography.md) で学んだハッシュ関数の応用で、大量の証明書を効率的に管理し、特定の証明書がログに含まれていることを少ないデータ量で証明できます

### DigiNotar 事件と CT の必要性

Certificate Transparency が必要になった背景には、実際のセキュリティ事故があります

<strong>2011 年の DigiNotar 事件</strong>は、PKI の信頼モデルに重大な問題を提起しました

DigiNotar はオランダの認証局でしたが、攻撃者にシステムを侵害されました

攻撃者は `google.com` をはじめとする多数のドメインに対して、不正な証明書を発行しました

これらの不正証明書は、イランにおけるインターネット通信の監視（中間者攻撃）に使われたとされています

問題が発覚したのは、Google が自社サービスの証明書を監視する仕組みを持っていたからです

しかし、すべてのドメイン管理者がこのような監視を行えるわけではありません

この事件の後、DigiNotar はすべてのブラウザのトラストストアから削除され、破産しました

DigiNotar 事件の教訓は明確です

<strong>認証局への信頼は、検証可能でなければならない</strong>

Certificate Transparency は、すべての証明書の発行を公開ログに記録することで、DigiNotar のような不正発行を早期に検出できるようにしました

なお、信頼されていた存在が悪用されるという構造は、ソフトウェアのサプライチェーンにも共通します

2024 年の xz-utils バックドア事件では、信頼されたメンテナの地位が悪用されました

この問題は [07-supply-chain](./07-supply-chain.md) で詳しく学びます

---

## 証明書の自動化と現代の課題

### Let's Encrypt と ACME プロトコル

2015 年以前、TLS 証明書の取得には費用がかかり、手動での設定が必要でした

この障壁が、HTTPS の普及を妨げていました

<strong>Let's Encrypt</strong> は、この状況を変えた非営利の認証局です

Let's Encrypt は無料の DV 証明書を提供し、<strong>ACME</strong>（Automatic Certificate Management Environment、RFC 8555）プロトコルで証明書の発行と更新を自動化しました

ACME プロトコルは、ドメインの管理権限を自動的に確認します

| チャレンジ方式 | 確認方法                                                |
| -------------- | ------------------------------------------------------- |
| HTTP-01        | 指定されたファイルを Web サーバーに配置できることを確認 |
| DNS-01         | 指定された DNS レコードを設定できることを確認           |

たとえば HTTP-01 チャレンジでは、Let's Encrypt が指定したトークンを `http://example.com/.well-known/acme-challenge/` に配置できることで、ドメインの管理権限を確認します

Let's Encrypt の影響は大きく、HTTPS の普及率は Let's Encrypt の開始前から大幅に上昇し、現在は 80% 以上のウェブサイトがデフォルトで HTTPS を使用しています

### 証明書の有効期間の短縮

証明書の有効期間は、歴史的に短縮されてきました

| 時期          | 最長有効期間         |
| ------------- | -------------------- |
| 2012 年以前   | 5 年（60 か月）      |
| 2015 年       | 3 年（39 か月）      |
| 2018 年       | 2 年（825 日）       |
| 2020 年       | 約 13 か月（398 日） |
| Let's Encrypt | 90 日                |

有効期間を短くするメリットは明確です

- 秘密鍵が漏洩した場合の影響期間が限定される
- 失効確認の信頼性が低くても（Soft-fail 問題）、リスクの期間が短い
- 自動化が前提になるため、人為的ミスが減る

一方で、有効期間が短いほど証明書の更新頻度が増えるため、<strong>自動化が必須</strong>になります

### 証明書ピンニングとその廃止

<strong>証明書ピンニング</strong>（Certificate Pinning）は、特定のサイトに対して使用される証明書や公開鍵を事前に記憶する仕組みです

HPKP（HTTP Public Key Pinning）は、サーバーが HTTP ヘッダで「この公開鍵を使うべき」とブラウザに伝える標準でした

しかし、HPKP には深刻な運用リスクがありました

- ピンを設定した鍵に対応する秘密鍵が失われると、サイトに一切アクセスできなくなる
- 攻撃者が HPKP ヘッダを注入すると、正規のサイトへのアクセスを妨害できる（HPKP スーパークッキー問題）

Chrome は 2018 年に HPKP のサポートを廃止しました

この経験は重要な教訓を示しています

<strong>セキュリティの強化が、可用性を著しく損なう場合、その仕組みは持続しない</strong>

Certificate Transparency は、ピンニングのような厳密な制限なしに不正発行を検出できるため、より実用的な代替手段となりました

### 信頼モデルの限界

PKI の信頼モデルは技術的な仕組みだけでは完結せず、認証局の<strong>ガバナンス</strong>（統治）が不可欠です

<strong>2017 年の Symantec 事件</strong>がこの問題を浮き彫りにしました

Google と Mozilla の調査により、Symantec 傘下の認証局が数千件の証明書を不適切に発行していたことが判明しました

不適切な発行には、ドメイン管理者の承認なしに発行された証明書や、検証手続きを省略した証明書が含まれていました

Symantec は世界最大級の認証局でしたが、ブラウザベンダーは段階的に Symantec の証明書を信頼しなくなりました

この事件は、PKI の信頼モデルにおける重要な原則を示しています

- <strong>認証局の規模は信頼の保証にならない</strong>：最大手の認証局でも、不適切な運営は許容されない
- <strong>ブラウザベンダーが最終的な信頼の番人である</strong>：トラストストアの管理者が、認証局の信頼を決定する権限を持つ
- <strong>技術とガバナンスの両方が必要</strong>：証明書の暗号的な正しさだけでなく、認証局の運営プロセスの適切さが信頼の基盤である

---

## 次のトピックへ

このトピックでは、以下のことを学びました

- 証明書は公開鍵と身元情報を結びつけ、認証局のデジタル署名で保証される
- X.509 は証明書の標準形式であり、Subject、Issuer、Public Key、Validity、SAN などのフィールドを含む
- PKI は認証局の階層構造（ルート CA → 中間 CA → エンドエンティティ）による信頼の連鎖で成り立つ
- ブラウザはトラストストアのルート CA を起点に、証明書チェーンの署名・有効期間・ドメイン名を検証する
- 証明書の失効は CRL と OCSP で管理されるが、Soft-fail 問題があり、有効期間の短縮で補完されている
- Certificate Transparency は認証局の不正発行を公開ログで監視する仕組みであり、Chrome は SCT を必須としている
- Let's Encrypt と ACME による証明書の自動化が HTTPS の普及を加速した
- PKI の信頼モデルは、技術だけでなく認証局のガバナンスに依存している

しかし、ここで重要な疑問が残ります

証明書によって<strong>サーバーの身元</strong>は確認できるようになりましたが、サーバーにアクセスする<strong>ユーザーの身元</strong>はどのように確認するのでしょうか？

パスワードによる認証は、内部的にどのような仕組みで安全に行われているのでしょうか？

「認証」（あなたは誰か）と「認可」（あなたは何ができるか）は、どう違うのでしょうか？

Web サービスで広く使われる OAuth や JWT は、どのような原理で動いているのでしょうか？

次のトピック [04-authentication](./04-authentication.md) では、<strong>認証と認可</strong>の仕組みを学びます

---

## 用語集

| 用語                                                 | 説明                                                                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| 証明書（Certificate）                                | 公開鍵と身元情報を結びつけ、認証局のデジタル署名で保証された電子的な文書                                     |
| X.509                                                | ITU-T が定義し RFC 5280 で規定された、インターネットで最も広く使われる証明書の標準形式                       |
| 認証局（CA：Certificate Authority）                  | 証明書を発行する信頼された機関。申請者の身元を確認し、デジタル署名で証明書を保証する                         |
| ルート CA（Root CA）                                 | 信頼の連鎖の頂点に位置する認証局。自己署名証明書を持ち、OS やブラウザのトラストストアに格納される            |
| 中間 CA（Intermediate CA）                           | ルート CA から証明書を発行された認証局。ルート CA の代わりにエンドエンティティ証明書を発行する               |
| エンドエンティティ証明書                             | 証明書チェーンの末端にある証明書。サーバー証明書やクライアント証明書がこれに該当する                         |
| 証明書チェーン（Certificate Chain）                  | エンドエンティティ証明書からルート CA 証明書までの連鎖。信頼の連鎖とも呼ばれる                               |
| 自己署名証明書（Self-signed Certificate）            | 発行者と主体者が同一の証明書。ルート CA 証明書は自己署名である                                               |
| PKI（Public Key Infrastructure）                     | デジタル証明書の発行、管理、検証、失効を行うための基盤全体                                                   |
| トラストストア（Trust Store）                        | OS やブラウザが保持する信頼されたルート CA 証明書の一覧                                                      |
| トラストアンカー（Trust Anchor）                     | 信頼の起点となるルート CA 証明書。トラストストアに格納されている                                             |
| DV（Domain Validation）                              | ドメインの管理権限のみを確認して発行される証明書。最も基本的な検証レベル                                     |
| OV（Organization Validation）                        | 組織の実在性を確認して発行される証明書                                                                       |
| EV（Extended Validation）                            | 最も厳格な検証プロセスを経て発行される証明書                                                                 |
| SAN（Subject Alternative Name）                      | 1 つの証明書で複数のドメイン名を指定できる拡張フィールド                                                     |
| Basic Constraints                                    | 証明書が CA として機能できるかどうかを示す拡張フィールド。中間 CA 証明書で必須                               |
| CRL（Certificate Revocation List）                   | 認証局が公開する失効した証明書の一覧。RFC 5280 で定義                                                        |
| OCSP（Online Certificate Status Protocol）           | 証明書の失効状態をリアルタイムに問い合わせるプロトコル。RFC 6960 で定義                                      |
| OCSP Stapling                                        | サーバーが OCSP レスポンスを取得し、TLS ハンドシェイクに添付する仕組み                                       |
| Soft-fail                                            | 失効確認に失敗した場合にエラーにせず通信を続行するブラウザの動作。可用性を優先するがセキュリティリスクを伴う |
| Certificate Transparency（CT）                       | 発行されたすべての証明書を公開ログに記録し、不正発行を検出する仕組み。RFC 6962 で定義                        |
| SCT（Signed Certificate Timestamp）                  | CT ログが証明書の登録を証明するために発行する署名付きタイムスタンプ                                          |
| マークル木（Merkle Tree）                            | ハッシュ関数を使ったツリー構造。データの完全性と包含証明を効率的に行える                                     |
| Let's Encrypt                                        | 無料の DV 証明書を自動発行する非営利認証局                                                                   |
| ACME（Automatic Certificate Management Environment） | 証明書の発行・更新を自動化するプロトコル。RFC 8555 で定義                                                    |
| 証明書ピンニング（Certificate Pinning）              | 特定のサイトに対して使用される証明書や公開鍵を事前に記憶する仕組み                                           |
| HPKP（HTTP Public Key Pinning）                      | HTTP ヘッダで公開鍵のピンを指定する仕組み。運用リスクのため廃止された                                        |
| DigiNotar                                            | 2011 年に不正証明書の発行が発覚し、全ブラウザから信頼を削除された認証局                                      |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>証明書・PKI</strong>

- [RFC 5280 - Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile](https://datatracker.ietf.org/doc/html/rfc5280)
  - X.509 証明書と CRL の形式、証明書チェーンの検証手順

<strong>証明書の失効</strong>

- [RFC 6960 - X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP](https://datatracker.ietf.org/doc/html/rfc6960)
  - OCSP の仕様（リアルタイムの証明書失効確認）

<strong>Certificate Transparency</strong>

- [RFC 6962 - Certificate Transparency](https://datatracker.ietf.org/doc/html/rfc6962)
  - Certificate Transparency の仕様（公開ログ、SCT、マークル木）

<strong>証明書の自動化</strong>

- [RFC 8555 - Automatic Certificate Management Environment (ACME)](https://datatracker.ietf.org/doc/html/rfc8555)
  - ACME プロトコルの仕様（Let's Encrypt が使用する証明書自動発行プロトコル）
