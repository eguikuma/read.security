<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 05-access-control：アクセス制御モデル（誰が何をできるか）

## はじめに

前のトピック [04-authentication](./04-authentication.md) では、認証と認可の仕組みを学びました

- 認証は「あなたは誰か」を確認するプロセスであり、認可は「あなたは何ができるか」を決定するプロセスである
- パスワードはハッシュ化とソルトで保護し、鍵導出関数（bcrypt、Argon2）で計算コストを高めることでブルートフォース攻撃に対抗する
- セッションベース認証は Cookie とセッション ID でログイン状態を維持するが、サーバー側の状態管理が課題となる
- JWT はトークン自体にユーザー情報と署名を含むステートレスな認証方式であり、完全性と真正性を保証する
- OAuth 2.0 はパスワードを共有せずに権限を委譲するフレームワークであり、スコープで最小権限の原則を実現する
- 多要素認証は知識・所持・生体の異なる種類の要素を組み合わせて安全性を高める
- FIDO2 とパスキーは公開鍵暗号を応用したフィッシング耐性のある認証方式である
- ゼロトラストは「何も信頼せず、常に検証する」原則であり、認証と認可を継続的に行う

04-authentication の最後に、こう問いかけました

<strong>認証で「誰か」は確認できるようになりましたが、その人が「何をできるか」をどのように体系的に管理するのでしょうか？</strong>

OAuth のスコープはアクセス制御の一例ですが、組織全体のアクセス権限はどのようなモデルで管理されているのでしょうか？

RBAC（役割ベースアクセス制御）や ABAC（属性ベースアクセス制御）とは、どのような仕組みでしょうか？

OS レベルでは、プロセスのアクセス権限はどのように制御されているのでしょうか？

このトピックでは、<strong>アクセス制御モデル</strong>の仕組みを学びます

認証で確認された「誰か」に基づいて、「何をできるか」を体系的に管理する原理を理解します

---

## 日常の例え

アクセス制御の仕組みを、日常の例えで見てみましょう

<strong>アクセス制御 = オフィスビルの入館カード</strong>

オフィスビルの入口で入館カードをかざすと、ゲートが開きます

入口でカードをかざして本人確認をするのが「認証」です

認証の後、カードに紐づいたフロア制限に従って入れる場所が決まります

営業部の社員は 3 階の営業フロアに入れますが、4 階のサーバールームには入れません

この「誰がどのフロアに入れるか」を管理する仕組みが「アクセス制御」です

<strong>DAC（任意アクセス制御） = 自分の家の鍵の貸し借り</strong>

自分の家の合鍵を作って友人に渡すかどうかは、自分で自由に決められます

友人にも合鍵を渡す権限があれば、友人がさらに別の人に合鍵を渡すこともできてしまいます

所有者が自由に権限を管理できる反面、管理が行き届かなくなるリスクがあります

<strong>MAC（強制アクセス制御） = 軍事施設のセキュリティクリアランス</strong>

軍事施設では、情報に「極秘」「秘密」「一般」などの機密レベルが付けられています

職員にも「極秘まで閲覧可」「秘密まで閲覧可」といったクリアランス（許可レベル）が割り当てられます

自分のクリアランスより高い機密レベルの情報は、どれだけ必要でも閲覧できません

個人の判断で他の人にアクセスを許可することもできず、組織のポリシーが絶対的に適用されます

<strong>RBAC（ロールベースアクセス制御） = 病院の職種別アクセス</strong>

病院では「医師」「看護師」「受付」などの職種（役割）があります

医師はカルテの閲覧と編集ができ、看護師はカルテの閲覧とバイタル記録ができ、受付は患者の基本情報のみ閲覧できます

新しいスタッフが来たとき、その人の職種を指定するだけで、適切な権限が自動的に付与されます

権限は「個人」ではなく「役割」に紐づいているため、管理が効率的です

<strong>最小権限の原則 = バレーパーキングの鍵</strong>

[04-authentication](./04-authentication.md) の OAuth の例えで紹介したバレーキーの考え方は、アクセス制御全体を貫く原則です

バレーキーはエンジンの始動と低速走行だけが可能で、トランクやグローブボックスにはアクセスできません

必要以上の権限を与えないことで、問題が起きたときの被害を最小限に抑えます

---

## このページで学ぶこと

このページでは、以下の概念を学びます

<strong>アクセス制御の基本概念</strong>

- <strong>アクセス制御の三要素</strong>
  - 主体（Subject）、客体（Object）、操作（Action）の関係
- <strong>アクセス制御ポリシーとメカニズム</strong>
  - 「何を許可するか」の方針と、それを実施する仕組みの分離

<strong>アクセス制御モデル</strong>

- <strong>任意アクセス制御（DAC）</strong>
  - 所有者が権限を自由に管理するモデル
- <strong>強制アクセス制御（MAC）</strong>
  - システムのポリシーが絶対的に権限を管理するモデル
- <strong>ロールベースアクセス制御（RBAC）</strong>
  - 役割を介して権限を管理するモデル
- <strong>属性ベースアクセス制御（ABAC）</strong>
  - 属性とルールで動的に権限を判断するモデル

<strong>実システムのアクセス制御</strong>

- <strong>UNIX のファイル権限と Linux の capability</strong>
  - OS レベルのアクセス制御の仕組み
- <strong>データベースの GRANT / REVOKE</strong>
  - データベースレベルのアクセス制御の仕組み

<strong>統一原則</strong>

- <strong>最小権限の原則</strong>
  - すべてのアクセス制御に通じる基本原則

---

## 目次

1. [アクセス制御の基本概念](#アクセス制御の基本概念)
2. [任意アクセス制御（DAC）](#任意アクセス制御dac)
3. [強制アクセス制御（MAC）](#強制アクセス制御mac)
4. [ロールベースアクセス制御（RBAC）](#ロールベースアクセス制御rbac)
5. [属性ベースアクセス制御（ABAC）](#属性ベースアクセス制御abac)
6. [OS レベルのアクセス制御](#os-レベルのアクセス制御)
7. [データベースのアクセス制御](#データベースのアクセス制御)
8. [最小権限の原則](#最小権限の原則)
9. [次のトピックへ](#次のトピックへ)
10. [用語集](#用語集)
11. [参考資料](#参考資料)

---

## アクセス制御の基本概念

### アクセス制御とは

[04-authentication](./04-authentication.md) では、「認証」（あなたは誰か）と「認可」（あなたは何ができるか）の違いを学びました

<strong>アクセス制御</strong>は、この「認可」を具体的に実現する仕組みです

認証によって「誰か」が確認された後、アクセス制御によって「その人が何をできるか」が決定されます

アクセス制御の目的は、<strong>正当な主体には必要なアクセスを許可し、不正なアクセスを拒否すること</strong>です

### 三つの要素（Subject、Object、Action）

アクセス制御は、3 つの要素の関係で成り立っています

<strong>主体（Subject）</strong>：アクセスを要求する側です

ユーザー、プロセス、サービスなど、「何かをしたい」と要求する存在です

<strong>客体（Object）</strong>：アクセスされる側です

ファイル、データベースのテーブル、API エンドポイントなど、保護されたリソースです

<strong>操作（Action）</strong>：主体が客体に対して行いたい行為です

読み取り、書き込み、実行、削除など、客体に対する具体的な操作です

```
  アクセス制御の基本構造：

  ┌──────────┐              ┌──────────┐
  │   主体    │───操作──→│   客体    │
  │ (Subject) │              │ (Object) │
  │          │              │          │
  │ ユーザー   │   読み取り    │ ファイル   │
  │ プロセス   │   書き込み    │ テーブル   │
  │ サービス   │   実行       │ API      │
  └──────────┘   削除       └──────────┘
```

アクセス制御は、この「主体が客体に対して操作を行えるかどうか」を判断する仕組みです

| 主体       | 操作     | 客体                     | 判断の例                   |
| ---------- | -------- | ------------------------ | -------------------------- |
| ユーザー A | 読み取り | ファイル X               | 許可（所有者であるため）   |
| プロセス B | バインド | ポート 80                | 許可（権限を持つため）     |
| アプリ C   | 更新     | データベーステーブル Y   | 拒否（権限がないため）     |
| サービス D | 削除     | ストレージのオブジェクト | 拒否（読み取り専用のため） |

### ポリシーとメカニズム

アクセス制御には、「何を許可するか」と「どう実施するか」の 2 つの側面があります

<strong>ポリシー</strong>は、「誰が何をできるか」のルールです

「管理者はすべてのファイルを読み書きできる」「一般ユーザーは自分のファイルのみ編集できる」といった方針がポリシーにあたります

<strong>メカニズム</strong>は、ポリシーを実施する仕組みです

UNIX のファイルパーミッション、データベースの GRANT 文、ファイアウォールのルールなどがメカニズムにあたります

ポリシーとメカニズムを分離することで、ポリシーが変わってもメカニズムを変更する必要がなく、逆にメカニズムを変えてもポリシーに影響しません

### アクセス制御マトリクス

主体と客体の権限関係を整理する基本的な方法が<strong>アクセス制御マトリクス</strong>です

行が主体、列が客体、セルが許可された操作を表します

|            | ファイル A         | ファイル B         | データベース C     |
| ---------- | ------------------ | ------------------ | ------------------ |
| ユーザー X | 読み取り、書き込み | 読み取り           | なし               |
| ユーザー Y | 読み取り           | 読み取り、書き込み | 読み取り           |
| ユーザー Z | なし               | 読み取り           | 読み取り、書き込み |

このマトリクスをどのように実装し、管理するかによって、異なるアクセス制御モデルが生まれます

| モデル | 権限の管理者     | 特徴                         |
| ------ | ---------------- | ---------------------------- |
| DAC    | リソースの所有者 | 所有者が自由に権限を管理     |
| MAC    | システム管理者   | ポリシーが強制的に適用される |
| RBAC   | 組織の管理者     | 役割を介して権限を管理       |
| ABAC   | ポリシーエンジン | 属性に基づいて動的に判断     |

---

## 任意アクセス制御（DAC）

### DAC とは

<strong>DAC</strong>（Discretionary Access Control、任意アクセス制御）は、リソースの<strong>所有者</strong>が権限を自由に管理できるモデルです

「任意」とは、所有者の<strong>裁量</strong>（discretion）で権限を付与したり剥奪したりできるという意味です

日常の例えで紹介した「自分の家の合鍵を自由に貸し借りできる」という仕組みが DAC にあたります

### DAC の仕組み

DAC では、リソースの所有者がそのリソースへのアクセスを制御します

所有者は、他のユーザーに対して読み取り、書き込み、実行などの権限を自由に付与できます

```
  DAC の権限管理：

  ┌──────────┐
  │ ファイル X  │
  │ 所有者：A  │
  └────┬─────┘
       │
       │ 所有者 A が権限を管理
       │
       ├──→ ユーザー B に読み取りを許可
       ├──→ ユーザー C に読み取り・書き込みを許可
       └──→ ユーザー D にはアクセスを許可しない
```

DAC のアクセス制御マトリクスの実装方式は、大きく 2 つに分けられます

<strong>アクセス制御リスト（ACL）</strong>は、各客体に「誰がどの操作を許可されているか」のリストを持たせる方式です

アクセス制御マトリクスを列方向に見ています

ファイルに対して「ユーザー A は読み書き可、ユーザー B は読み取りのみ」というリストを付与します

<strong>ケイパビリティリスト</strong>は、各主体が「どの客体にどの操作が許可されているか」のリストを持つ方式です

アクセス制御マトリクスを行方向に見ています

ユーザーに対して「ファイル A は読み書き可、ファイル B は読み取りのみ」というリストを付与します

| 方式                 | 管理の視点           | 例                                         |
| -------------------- | -------------------- | ------------------------------------------ |
| ACL                  | 客体（リソース）ごと | ファイルに「誰がアクセスできるか」のリスト |
| ケイパビリティリスト | 主体（ユーザー）ごと | ユーザーに「何にアクセスできるか」のリスト |

### DAC の利点と課題

DAC の利点は<strong>柔軟性</strong>です

所有者がリソースの共有を自由に判断できるため、チーム内でのファイル共有などに適しています

しかし、DAC には課題もあります

所有者がユーザー B に権限を付与し、ユーザー B がさらにユーザー C に権限を渡すことができてしまう場合、所有者の意図しない範囲に権限が拡散します

この<strong>権限の伝播</strong>を制御することが難しいため、セキュリティ要件の高い環境では DAC だけでは不十分です

---

## 強制アクセス制御（MAC）

### MAC とは

<strong>MAC</strong>（Mandatory Access Control、強制アクセス制御）は、<strong>システム全体のポリシー</strong>が強制的に適用されるモデルです

「強制」とは、個々のユーザーや所有者の裁量では変更<strong>できない</strong>という意味です

DAC では所有者が自由に権限を管理できましたが、MAC ではシステム管理者が定めたポリシーが絶対的に適用されます

リソースの所有者であっても、ポリシーに反するアクセスを許可することはできません

### セキュリティラベルとクリアランス

MAC では、主体と客体のそれぞれに<strong>セキュリティレベル</strong>が割り当てられます

客体に付与されるレベルを<strong>セキュリティラベル</strong>、主体に割り当てられるレベルを<strong>クリアランス</strong>と呼びます

日常の例えで紹介した軍事施設のセキュリティクリアランスが、まさにこの仕組みです

```
  MAC のセキュリティレベル：

  高い ┌───────────────┐
      │  極秘（Top Secret）│ ← 最高機密の情報
      ├───────────────┤
      │  秘密（Secret）   │ ← 機密性の高い情報
      ├───────────────┤
      │  機密（Confidential）│ ← 内部向けの情報
      ├───────────────┤
  低い │  一般（Unclassified）│ ← 公開可能な情報
      └───────────────┘
```

MAC の代表的なモデルが<strong>Bell-LaPadula モデル</strong>です

Bell-LaPadula モデルは、情報の<strong>機密性</strong>を保護するために、2 つのルールを定めています

<strong>No Read Up</strong>（上位読み取り禁止）：自分のクリアランスより高いセキュリティラベルの情報は読めません

「秘密」クリアランスを持つ職員は、「極秘」ラベルの文書を閲覧できません

<strong>No Write Down</strong>（下位書き込み禁止）：自分のクリアランスより低いセキュリティラベルへの書き込みはできません

「極秘」クリアランスを持つ職員が「一般」ラベルの場所に情報を書き込むと、極秘情報が一般レベルに漏洩してしまうためです

| クリアランス | 極秘の文書   | 秘密の文書   | 機密の文書   | 一般の文書 |
| ------------ | ------------ | ------------ | ------------ | ---------- |
| 極秘         | 読み書き可   | 読み取り可   | 読み取り可   | 読み取り可 |
| 秘密         | 読み取り不可 | 読み書き可   | 読み取り可   | 読み取り可 |
| 機密         | 読み取り不可 | 読み取り不可 | 読み書き可   | 読み取り可 |
| 一般         | 読み取り不可 | 読み取り不可 | 読み取り不可 | 読み書き可 |

上の表は簡略化した例です

実際の Bell-LaPadula モデルでは「No Write Down」のルールがあるため、「極秘」クリアランスの職員は「秘密」以下のラベルへの書き込みも制限されます

### MAC の利点と課題

MAC の利点は、情報の流出を<strong>体系的に防止</strong>できることです

ポリシーが一元管理されるため、個々のユーザーの判断ミスによる情報漏洩を防げます

一方、課題は<strong>設定の複雑さと柔軟性の低さ</strong>です

すべてのリソースと主体にセキュリティレベルを適切に割り当てる必要があり、運用コストが高くなります

MAC は軍事・政府機関のほか、Linux カーネルのセキュリティモジュールとしても実装されています

<strong>SELinux</strong>（Security-Enhanced Linux）は、Linux カーネルに MAC を実装するモジュールです

すべてのプロセスとファイルにセキュリティコンテキスト（ラベル）を付与し、ポリシーに基づいてアクセスを制御します

<strong>AppArmor</strong> も同様に Linux に MAC を実装するモジュールですが、SELinux よりもプロファイル（設定）の記述が簡易です

---

## ロールベースアクセス制御（RBAC）

### RBAC とは

<strong>RBAC</strong>（Role-Based Access Control、ロールベースアクセス制御）は、<strong>役割（ロール）</strong>を介して権限を管理するモデルです

DAC や MAC では、主体と客体の間で直接権限を管理していました

RBAC では、主体と権限の間に「ロール」という概念を挟み、ユーザーにはロールを割り当て、ロールに権限を紐づけます

[04-authentication](./04-authentication.md) で学んだ OAuth のスコープは「個別のアクセス権限の制限」でしたが、RBAC は「組織全体の権限を体系的に管理する」ためのモデルです

### RBAC の仕組み

RBAC の核心は、<strong>ユーザーに直接権限を付与しない</strong>ことです

```
  RBAC の構造：

  ┌──────────┐     ┌──────────┐     ┌──────────────┐
  │ ユーザー   │     │  ロール   │     │ パーミッション  │
  │          │     │          │     │              │
  │ 田中さん   │──→│ 管理者    │──→│ ユーザー作成   │
  │          │     │          │  ├→│ ユーザー削除   │
  │ 佐藤さん   │──→│ 編集者    │──→│ 記事作成      │
  │          │     │          │  ├→│ 記事編集      │
  │ 鈴木さん   │──→│ 閲覧者    │──→│ 記事閲覧      │
  └──────────┘     └──────────┘     └──────────────┘
```

ユーザーにはロールを割り当て、ロールにはパーミッション（権限）を割り当てます

新しい社員が入社したとき、その人の職務に対応するロールを割り当てるだけで、必要な権限がすべて付与されます

退職時にはロールを外すだけで、すべての権限を一括して剥奪できます

個人ごとに権限を管理する場合と比べて、管理コストが大幅に削減されます

### ロール階層と責務分離

RBAC には、権限管理をさらに効率化する仕組みがあります

<strong>ロール階層</strong>は、上位のロールが下位のロールの権限を継承する仕組みです

```
  ロール階層の例：

  ┌──────────┐
  │ 管理者    │ ← 編集者と閲覧者の権限をすべて含む
  └────┬─────┘    + ユーザー管理の権限
       │
  ┌────┴─────┐
  │ 編集者    │ ← 閲覧者の権限をすべて含む
  └────┬─────┘    + 記事の作成・編集の権限
       │
  ┌────┴─────┐
  │ 閲覧者    │ ← 記事の閲覧のみ
  └──────────┘
```

「管理者」ロールは「編集者」の権限をすべて含み、さらに管理権限を持ちます

ロール階層によって、権限の定義を重複させる必要がなくなります

<strong>責務分離</strong>（Separation of Duties）は、1 人のユーザーが過剰な権限を持つことを防ぐ制約です

<strong>静的責務分離</strong>は、同時に割り当てられないロールの組み合わせを定める制約です

たとえば、「申請者」ロールと「承認者」ロールを同一のユーザーに割り当てることを禁止します

1 人が申請と承認の両方を行えると、不正な取引が可能になってしまうためです

<strong>動的責務分離</strong>は、同時に<strong>有効化</strong>できないロールの制約です

ユーザーが複数のロールを持っていても、特定のロールの組み合わせを同時に使うことを禁止します

### RBAC の利点と課題

RBAC は現在最も広く使われているアクセス制御モデルです

| 利点                     | 説明                                                             |
| ------------------------ | ---------------------------------------------------------------- |
| 管理の効率化             | ユーザー個別ではなくロール単位で権限を管理できる                 |
| 組織構造との対応         | 部門や職位などの組織構造をロール階層に反映できる                 |
| 監査の容易さ             | 「誰がどのロールを持っているか」を確認するだけで権限を把握できる |
| オンボーディングの簡素化 | 新メンバーにロールを割り当てるだけで適切な権限が付与される       |

一方、RBAC には<strong>ロール爆発</strong>という課題があります

組織が複雑になると、「営業部の東京オフィスの課長」「開発部の大阪オフィスの一般社員」のように、部門・拠点・役職の組み合わせごとにロールが必要になります

組み合わせが増えるほどロールの数が膨大になり、管理が困難になります

また、「平日の業務時間内だけアクセスを許可したい」といった<strong>条件付きのアクセス制御</strong>は、RBAC では表現が難しくなります

---

## 属性ベースアクセス制御（ABAC）

### ABAC とは

<strong>ABAC</strong>（Attribute-Based Access Control、属性ベースアクセス制御）は、主体、客体、環境の<strong>属性</strong>に基づいてアクセスを動的に判断するモデルです

NIST SP 800-162 では、ABAC を次のように定義しています

> Authorization to perform a set of operations is determined by evaluating attributes associated with the subject, object, requested operations, and, in some cases, environment conditions against policy, rules, or relationships that describe the allowable operations for a given set of attributes.

> 一連の操作を実行する認可は、主体・客体・要求された操作、そして場合によっては環境条件に関連づけられた属性を、許可される操作を記述するポリシー・ルール・関係に照らして評価することで決定される

ABAC は、RBAC の「ロール爆発」問題を解決するアプローチです

ロールという固定的な概念ではなく、さまざまな属性の組み合わせでアクセスを判断します

### ABAC の三種の属性

ABAC では、3 種類の属性を使ってアクセスを判断します

<strong>主体属性</strong>：アクセスを要求する主体の特性です

部署、役職、セキュリティクリアランス、所属プロジェクトなどが主体属性にあたります

<strong>客体属性</strong>：アクセスされるリソースの特性です

データの分類（社外秘、社内向け、公開）、作成日、ファイルの種類などが客体属性にあたります

<strong>環境属性</strong>：アクセスが行われる状況の特性です

時刻、場所、ネットワーク環境（社内 / 社外）、デバイスの種類などが環境属性にあたります

```
  ABAC のアクセス判断：

  ┌─────────┐   ┌─────────┐   ┌─────────┐
  │ 主体属性  │   │ 客体属性  │   │ 環境属性  │
  │ 部署：営業│   │ 分類：社内│   │ 時刻：業務│
  │ 役職：課長│   │ レベル：中│   │ 場所：社内│
  └────┬────┘   └────┬────┘   └────┬────┘
       │             │             │
       └──────┬──────┘─────────────┘
              │
              ▼
       ┌──────────────────────────────────────┐
       │ ポリシーエンジン                        │
       │                                      │
       │ ルール：「営業部の課長以上」             │
       │     AND「社内文書」                    │
       │     AND「業務時間内 AND 社内アクセス」   │
       │                                      │
       │ → アクセス許可                         │
       └──────────────────────────────────────┘
```

たとえば、「営業部の課長が、業務時間内に、社内ネットワークからアクセスする場合のみ、社外秘の営業資料を閲覧できる」というポリシーは、ABAC であれば 1 つのルールで表現できます

RBAC でこれを実現しようとすると、「営業部課長・社内・業務時間」という非常に限定的なロールを作成する必要があり、ロール爆発につながります

### RBAC と ABAC の比較

| 観点         | RBAC                         | ABAC                                 |
| ------------ | ---------------------------- | ------------------------------------ |
| 判断の基準   | ロール（役割）               | 属性（主体・客体・環境）             |
| 柔軟性       | ロールの追加で対応           | 属性とルールの組み合わせで対応       |
| 管理の複雑さ | ロール数が増えると管理が困難 | ルールが複雑になると管理が困難       |
| 適する環境   | 組織構造が安定している環境   | 動的な条件でアクセスを制御したい環境 |
| 導入の容易さ | 比較的容易                   | ポリシーエンジンの設計が必要         |

RBAC と ABAC は排他的ではなく、組み合わせて使うことも多くあります

基本的な権限管理は RBAC で行い、きめ細かい条件付き制御を ABAC で補完する、という構成です

[04-authentication](./04-authentication.md) で学んだ<strong>ゼロトラスト</strong>の「アクセスのたびにリスクを評価する」という考え方は、ABAC の思想に近いものです

ゼロトラストでは、アクセス元のネットワーク（環境属性）、デバイスの状態（主体属性）、アクセス先のリソースの機密レベル（客体属性）など、複数の属性を組み合わせてアクセスの可否を判断します

---

## OS レベルのアクセス制御

### UNIX ファイルパーミッション

UNIX / Linux のファイルパーミッションは、<strong>DAC の具体的な実装</strong>です

すべてのファイルとディレクトリに対して、3 つのカテゴリの主体に 3 つの権限を設定します

| カテゴリ          | 説明                                       |
| ----------------- | ------------------------------------------ |
| 所有者（Owner）   | ファイルを作成したユーザー                 |
| グループ（Group） | ファイルに関連づけられたグループ           |
| その他（Others）  | 所有者でもグループメンバーでもないユーザー |

| 権限          | ファイルの場合       | ディレクトリの場合                       |
| ------------- | -------------------- | ---------------------------------------- |
| 読み取り（r） | ファイルの内容を読む | ディレクトリの内容を一覧する             |
| 書き込み（w） | ファイルを変更する   | ディレクトリ内にファイルを作成・削除する |
| 実行（x）     | ファイルを実行する   | ディレクトリに移動する                   |

ファイルの所有者が他のユーザーへの権限を自由に設定できる点が、DAC の特徴です

しかし、UNIX のファイルパーミッションには根本的な問題があります

<strong>root ユーザー</strong>（UID 0）は、すべてのパーミッションチェックを迂回できる特権ユーザーです

root であれば、どのファイルでも読み書きでき、どのプロセスでも停止でき、システムのあらゆる操作が可能です

つまり、root 権限で動作するプロセスが攻撃者に乗っ取られると、システム全体が危険にさらされます

### Linux capabilities

root の「すべてが許可される」全能的な権限は、最小権限の原則に反しています

この問題を解決するために、Linux カーネルは root の権限を細分化する<strong>capability</strong>（ケイパビリティ）の仕組みを導入しました

> Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled.

> Linux は、従来スーパーユーザーに付与されていた特権を、ケイパビリティと呼ばれる独立した単位に分割し、個別に有効化・無効化できるようにした

```
  root 権限の細分化：

  従来の root 権限：
  ┌────────────────────────────────────────┐
  │ root = すべての操作が許可される           │
  └────────────────────────────────────────┘

  capability による細分化：
  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
  │ NET_BIND │ │ CHOWN   │ │ DAC_    │ │ SYS_    │
  │ _SERVICE │ │         │ │ OVERRIDE│ │ ADMIN   │
  └─────────┘ └─────────┘ └─────────┘ └─────────┘
  プロセスに必要な capability のみを付与する
```

代表的な capability は以下のとおりです

| capability           | 権限                                       |
| -------------------- | ------------------------------------------ |
| CAP_NET_BIND_SERVICE | 1024 未満の特権ポートにバインドする        |
| CAP_CHOWN            | ファイルの所有者を変更する                 |
| CAP_DAC_OVERRIDE     | ファイルのパーミッションチェックを迂回する |
| CAP_NET_RAW          | RAW ソケットを使用する                     |
| CAP_SYS_ADMIN        | さまざまなシステム管理操作を行う           |
| CAP_SYS_PTRACE       | 他のプロセスをトレース・検査する           |

たとえば、Web サーバーがポート 80（1024 未満の特権ポート）でリクエストを受け付ける場合、従来は root 権限で起動する必要がありました

capability を使えば、CAP_NET_BIND_SERVICE だけを付与することで、root 権限なしにポート 80 にバインドできます

Web サーバーのプロセスが攻撃者に乗っ取られても、ファイルの所有者変更やシステム管理操作はできないため、被害が限定されます

コンテナの学習では、コンテナ内のプロセスに必要最小限の capability のみを付与することで、コンテナからの権限昇格を防ぐ仕組みを学びました

capability は、その仕組みの基盤にあるアクセス制御の原理です

### seccomp

<strong>seccomp</strong>（Secure Computing Mode）は、プロセスが呼び出せる<strong>システムコール</strong>を制限する仕組みです

capability が「プロセスに何の権限を持たせるか」を制御するのに対し、seccomp は「プロセスが OS にどの操作を要求できるか」を制御します

Linux カーネルは数百のシステムコールを提供していますが、一般的なアプリケーションが使うのはその一部です

<strong>seccomp-bpf</strong> は、BPF（Berkeley Packet Filter）を使ってシステムコールをフィルタリングするモードです

プロセスが許可されていないシステムコールを呼び出すと、カーネルがそのプロセスを強制終了するか、エラーを返します

| 観点       | capability               | seccomp                         |
| ---------- | ------------------------ | ------------------------------- |
| 制御対象   | プロセスの特権操作       | プロセスのシステムコール        |
| 制御の粒度 | 権限の種類（約 40 種類） | システムコール単位（数百種類）  |
| 主な用途   | root 権限の細分化        | 攻撃対象面の縮小                |
| 制御の方向 | 「何ができるか」を制限   | 「OS に何を要求できるか」を制限 |

コンテナの学習では、seccomp プロファイルによってコンテナ内のプロセスが呼び出せるシステムコールを制限する仕組みを学びました

capability と seccomp を組み合わせることで、プロセスの権限とシステムコールの両面からアクセスを制御し、<strong>多層的な防御</strong>を実現しています

---

## データベースのアクセス制御

### GRANT と REVOKE

データベースのアクセス制御は、<strong>RBAC の具体的な実装</strong>です

データベースの学習では、GRANT / REVOKE による権限管理の具体的な操作を学びました

ここでは、その仕組みがアクセス制御モデルのどこに位置づけられるかを見ていきます

<strong>GRANT</strong> は、主体（ユーザーやロール）に権限を付与するコマンドです

<strong>REVOKE</strong> は、主体から権限を剥奪するコマンドです

データベースの権限は、アクセス制御の三要素に直接対応しています

| アクセス制御の要素 | データベースでの対応              | 例                            |
| ------------------ | --------------------------------- | ----------------------------- |
| 主体（Subject）    | ユーザー / ロール                 | `app_user`、`readonly_role`   |
| 客体（Object）     | テーブル / ビュー / 関数          | `orders`、`customers`         |
| 操作（Action）     | SELECT / INSERT / UPDATE / DELETE | 読み取り / 作成 / 更新 / 削除 |

RBAC の考え方に基づいて、データベースでも個々のユーザーに直接権限を付与するのではなく、ロールに権限を付与し、ユーザーにロールを割り当てるのが一般的です

### 権限の階層

データベースのアクセス制御は、複数の階層で構成されています

```
  データベースの権限階層：

  ┌────────────────────────────────┐
  │ データベースレベル                │
  │ （データベース全体への権限）      │
  ├────────────────────────────────┤
  │ スキーマレベル                   │
  │ （スキーマ内のすべてのテーブル）  │
  ├────────────────────────────────┤
  │ テーブルレベル                   │
  │ （特定テーブルへの権限）         │
  ├────────────────────────────────┤
  │ カラムレベル                    │
  │ （特定カラムへの権限）           │
  └────────────────────────────────┘
```

上位の階層で付与された権限は、下位の階層にも適用されます

データベースレベルで読み取り権限を付与すれば、そのデータベース内のすべてのテーブルを読み取れます

逆に、カラムレベルで特定のカラムだけに権限を限定することも可能です

最小権限の原則に従えば、必要なテーブルの必要なカラムにだけ権限を付与するのが望ましい構成です

### 行レベルセキュリティ

<strong>行レベルセキュリティ</strong>（Row-Level Security）は、同じテーブル内でも<strong>行ごと</strong>にアクセスを制御する仕組みです

通常のテーブルレベルの権限では、テーブルに SELECT 権限があれば、そのテーブルのすべての行を読み取れます

行レベルセキュリティを使うと、ユーザーの属性（所属部署など）に基づいて、閲覧できる行を制限できます

たとえば、営業テーブルに行レベルセキュリティを設定すると、東京オフィスの社員は東京の営業データのみ、大阪オフィスの社員は大阪の営業データのみを閲覧できます

同じクエリを実行しても、ユーザーによって返される結果が異なります

この仕組みは、ABAC の考え方に近いものです

行の属性（地域コード）と主体の属性（所属オフィス）を照合してアクセスを判断しています

---

## 最小権限の原則

### すべてのアクセス制御を貫く原則

このトピックで学んだすべてのアクセス制御モデルと実装に共通する原則があります

<strong>最小権限の原則</strong>（Principle of Least Privilege）です

最小権限の原則とは、<strong>主体にはその機能を実行するために必要な最小限の権限のみを付与する</strong>というセキュリティの原則です

この原則は、[04-authentication](./04-authentication.md) で学んだ OAuth のスコープから、このトピックで学んだ capability やデータベースの GRANT まで、すべてのアクセス制御に通じています

### 最小権限が重要な理由

最小権限の原則が重要である理由は 3 つあります

<strong>被害の限定</strong>：アカウントやプロセスが侵害された場合、そのアカウントが持つ権限の範囲でしか被害が発生しません

権限が最小限であれば、侵害されても被害は限定されます

<strong>事故の防止</strong>：必要以上の権限を持っていると、操作ミスによって意図しない変更や削除が行われるリスクがあります

権限を限定することで、操作ミスの影響範囲を小さくできます

<strong>監査の容易さ</strong>：権限が明確に定義されていれば、「誰が何をしたか」の追跡が容易になります

過剰な権限が付与されていると、不正な操作と正当な操作の区別が困難になります

### 最小権限の実践（横断的なまとめ）

最小権限の原則は、このトピックで学んだあらゆるレイヤで実践されています

| レイヤ              | 最小権限の実践                               |
| ------------------- | -------------------------------------------- |
| OAuth スコープ      | 必要最小限のスコープのみを要求する           |
| RBAC                | 職務に必要なロールのみを割り当てる           |
| ABAC                | 条件に合致する場合のみアクセスを許可する     |
| UNIX パーミッション | ファイルに必要最小限の権限のみを設定する     |
| Linux capability    | プロセスに必要な capability のみを付与する   |
| seccomp             | プロセスが必要なシステムコールのみを許可する |
| データベース GRANT  | 必要なテーブルの必要な操作のみを許可する     |

### デフォルト拒否

最小権限の原則と対になるのが<strong>デフォルト拒否</strong>（Default Deny）の考え方です

デフォルト拒否とは、<strong>明示的に許可されていないアクセスはすべて拒否する</strong>という方針です

アクセス制御の設計には、2 つのアプローチがあります

<strong>許可リスト方式</strong>（ホワイトリスト）：許可するものだけを列挙し、それ以外はすべて拒否します

<strong>拒否リスト方式</strong>（ブラックリスト）：拒否するものだけを列挙し、それ以外はすべて許可します

デフォルト拒否は許可リスト方式の考え方です

拒否リスト方式では、新たな脅威や想定外のアクセスパターンに対応できません

「想定外のアクセスは許可される」という状態は、セキュリティ上のリスクです

seccomp のデフォルトプロファイルも、デフォルト拒否の考え方で設計されています

「すべてのシステムコールを拒否し、必要なものだけを許可する」というアプローチです

最小権限の原則とデフォルト拒否は、アクセス制御の設計における<strong>最も基本的な原則</strong>です

---

## 次のトピックへ

このトピックでは、以下のことを学びました

- アクセス制御は主体（Subject）、客体（Object）、操作（Action）の三要素で構成される
- DAC は所有者が権限を自由に管理するモデルであり、UNIX ファイルパーミッションが代表例である
- MAC はシステムポリシーが強制的に権限を管理するモデルであり、セキュリティラベルとクリアランスで情報の流出を防ぐ
- RBAC は役割を介して権限を管理するモデルであり、組織構造に対応しやすく管理が効率的である
- ABAC は主体・客体・環境の属性に基づいて動的にアクセスを判断するモデルであり、きめ細かい制御が可能である
- Linux の capability は root の全能的な権限を細分化し、プロセスに必要最小限の権限のみを付与する仕組みである
- seccomp はプロセスが呼び出せるシステムコールを制限する仕組みであり、capability と組み合わせて多層的な防御を実現する
- データベースの GRANT / REVOKE は RBAC の具体的な実装であり、権限の階層と行レベルセキュリティできめ細かい制御が可能である
- 最小権限の原則とデフォルト拒否は、すべてのアクセス制御に通じる基本原則である

しかし、ここで重要な疑問が残ります

<strong>アクセス制御で「誰が何をできるか」を管理できるようになりましたが、アプリケーションに送られる「入力」自体が悪意を持つ場合、どのように防御するのでしょうか？</strong>

SQL インジェクションや XSS（クロスサイトスクリプティング）のような攻撃は、正当な権限を持つユーザーの入力を通じて発生しますが、どのような原則で防ぐのでしょうか？

認証、アクセス制御、入力検証など、複数の防御を組み合わせる「多層防御」とは、どのような考え方でしょうか？

次のトピック [06-application-security](./06-application-security.md) では、<strong>アプリケーションセキュリティ</strong>の仕組みを学びます

---

## 用語集

| 用語                                           | 説明                                                                                                                  |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| アクセス制御（Access Control）                 | 主体が客体に対してどの操作を実行できるかを管理する仕組み。認証の後に行われ、認可を具体的に実現する                    |
| 主体（Subject）                                | アクセスを要求する側。ユーザー、プロセス、サービスなど                                                                |
| 客体（Object）                                 | アクセスされる対象。ファイル、データベーステーブル、API エンドポイントなど                                            |
| 操作（Action / Permission）                    | 主体が客体に対して行う行為。読み取り、書き込み、実行、削除など                                                        |
| アクセス制御マトリクス                         | 主体と客体の権限関係を行列形式で表現したモデル。行が主体、列が客体、セルが許可された操作を表す                        |
| ポリシー（Policy）                             | 「誰が何をできるか」のルール。アクセス制御の方針を定義する                                                            |
| メカニズム（Mechanism）                        | ポリシーを実施する仕組み。ファイルパーミッションや GRANT 文など                                                       |
| ACL（Access Control List）                     | 各客体に「誰がどの操作を許可されているか」のリストを持たせる方式。アクセス制御マトリクスの列方向の実装                |
| ケイパビリティリスト（Capability List）        | 各主体が「どの客体にどの操作が許可されているか」のリストを持つ方式。アクセス制御マトリクスの行方向の実装              |
| DAC（Discretionary Access Control）            | 任意アクセス制御。リソースの所有者が権限を自由に管理できるモデル。UNIX ファイルパーミッションが代表例                 |
| MAC（Mandatory Access Control）                | 強制アクセス制御。システム全体のポリシーが強制的に適用されるモデル。個々のユーザーの裁量では変更できない              |
| セキュリティラベル（Security Label）           | MAC において客体に付与される機密レベル。極秘、秘密、機密、一般など                                                    |
| クリアランス（Clearance）                      | MAC において主体に割り当てられる許可レベル。セキュリティラベルに対応する                                              |
| Bell-LaPadula モデル                           | MAC の代表的なモデル。No Read Up（上位読み取り禁止）と No Write Down（下位書き込み禁止）で情報の機密性を保護する      |
| RBAC（Role-Based Access Control）              | ロールベースアクセス制御。役割を介して権限を管理するモデル。ユーザーにロールを割り当て、ロールに権限を紐づける        |
| ロール（Role）                                 | 権限の集合。ユーザーにロールを割り当てることで権限を付与する。「管理者」「編集者」「閲覧者」など                      |
| ロール階層（Role Hierarchy）                   | 上位のロールが下位のロールの権限を継承する仕組み。管理者は編集者の権限をすべて含むなど                                |
| 責務分離（Separation of Duties）               | 1 人のユーザーが過剰な権限を持つことを防ぐ制約。静的責務分離と動的責務分離がある                                      |
| ロール爆発（Role Explosion）                   | 組織が複雑になるとロールの数が膨大になり管理が困難になる RBAC の課題                                                  |
| ABAC（Attribute-Based Access Control）         | 属性ベースアクセス制御。主体・客体・環境の属性に基づいてアクセスを動的に判断するモデル                                |
| 主体属性（Subject Attribute）                  | ABAC において主体の特性を表す属性。部署、役職、クリアランスなど                                                       |
| 客体属性（Object Attribute）                   | ABAC において客体の特性を表す属性。データの分類、機密レベル、作成日など                                               |
| 環境属性（Environment Attribute）              | ABAC においてアクセス要求の状況を表す属性。時刻、場所、ネットワーク環境など                                           |
| UNIX ファイルパーミッション                    | DAC の実装例。所有者・グループ・その他の 3 カテゴリに読み取り・書き込み・実行の権限を設定する                         |
| capability（Linux capabilities）               | root の全能的な権限を細分化した仕組み。プロセスに必要な capability のみを付与することで最小権限を実現する             |
| CAP_NET_BIND_SERVICE                           | 1024 未満の特権ポートにバインドする権限を持つ capability                                                              |
| seccomp（Secure Computing Mode）               | プロセスが呼び出せるシステムコールを制限する Linux カーネルの仕組み。攻撃対象面を縮小する                             |
| seccomp-bpf                                    | BPF（Berkeley Packet Filter）を使ってシステムコールをフィルタリングする seccomp のモード                              |
| GRANT                                          | データベースにおいて主体に権限を付与するコマンド                                                                      |
| REVOKE                                         | データベースにおいて主体から権限を剥奪するコマンド                                                                    |
| 行レベルセキュリティ（Row-Level Security）     | 同じテーブル内で行ごとにアクセスを制御する仕組み。行の属性と主体の属性を照合して判断する                              |
| 最小権限の原則（Principle of Least Privilege） | 主体にはその機能を実行するために必要な最小限の権限のみを付与するセキュリティの原則                                    |
| デフォルト拒否（Default Deny）                 | 明示的に許可されていないアクセスをすべて拒否する方針。許可リスト方式とも呼ばれる                                      |
| SELinux（Security-Enhanced Linux）             | Linux カーネルに MAC を実装するセキュリティモジュール。すべてのプロセスとファイルにセキュリティコンテキストを付与する |
| AppArmor                                       | Linux カーネルに MAC を実装するセキュリティモジュール。SELinux より設定が簡易                                         |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>アクセス制御モデル</strong>

- [NIST SP 800-162 - Guide to Attribute Based Access Control (ABAC) Definition and Considerations](https://csrc.nist.gov/pubs/sp/800/162/final)
  - 属性ベースアクセス制御の定義、DAC・MAC・RBAC・ABAC の比較と考慮事項

<strong>Linux のアクセス制御</strong>

- [capabilities(7) - Linux manual page](https://man7.org/linux/man-pages/man7/capabilities.7.html)
  - Linux capabilities の仕組み、各 capability の定義と用途
- [seccomp(2) - Linux manual page](https://man7.org/linux/man-pages/man2/seccomp.2.html)
  - seccomp の仕組み、seccomp-bpf によるシステムコールのフィルタリング
