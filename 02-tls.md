<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# 02-tls：TLS の原理（なぜ安全か）

## はじめに

前のトピック [01-cryptography](./01-cryptography.md) では、暗号化の基礎を学びました

- 対称暗号は同じ鍵で暗号化と復号を行い、高速だが鍵配送問題がある
- 非対称暗号は公開鍵と秘密鍵のペアを使い、鍵配送問題を解決するが処理が遅い
- ハッシュ関数は一方向性・衝突耐性・雪崩効果の性質を持ち、データの完全性検証に使われる
- Diffie-Hellman 鍵交換は、安全でない通信路で共有秘密を作り出す
- AEAD は暗号化と改ざん検出を同時に行う

01-cryptography の最後に、こう問いかけました

<strong>これらの暗号化技術は、具体的にどう組み合わされて通信を安全にしているのでしょうか？</strong>

TLS ハンドシェイクでは、なぜ 1 往復で安全な鍵を共有できるのでしょうか？

前方秘匿性は、プロトコル上でどのように実現されているのでしょうか？

0-RTT にはどのようなリスクがあるのでしょうか？

このトピックでは、TLS 1.3（RFC 8446）を題材に、暗号化技術の組み合わせが「なぜ安全か」という原理を学びます

前のシリーズでは TLS の<strong>プロトコル動作</strong>（何がどの順に起こるか）を学びました

このトピックでは、そのプロトコルの<strong>セキュリティ上の根拠</strong>（なぜその手順で安全になるのか）に焦点を当てます

---

## 日常の例え

TLS のセキュリティ上の仕組みを、日常の例えで見てみましょう

<strong>前方秘匿性 = 毎回使い捨てる暗号ノート</strong>

友人と秘密のやり取りをするとき、毎回新しい暗号ノートを使い、やり取りが終わったら破棄するとします

もし 1 冊のノートが盗まれても、他のノートの内容は解読できません

TLS の<strong>前方秘匿性</strong>も同じで、セッションごとに使い捨ての鍵を使うため、1 つの鍵が漏洩しても他のセッションは安全です

<strong>鍵導出 = マスターキーから部屋ごとの鍵を作る</strong>

ホテルのマスターキーから、各部屋の専用鍵を作ることを想像してください

書斎の鍵が盗まれても、寝室やリビングの鍵としては使えません

TLS の<strong>鍵導出</strong>も同じで、1 つの共有秘密から用途ごとに異なる鍵を作り出します

<strong>0-RTT = 顔パスの常連客</strong>

以前訪れたレストランで、「前と同じ注文で」と入店と同時に注文できるとします

待ち時間がなく速いですが、別人が「あの常連の注文で」と偽る（リプレイ攻撃）リスクがあります

TLS の <strong>0-RTT</strong> も同じで、速さと引き換えにセキュリティ上のリスクを受け入れる仕組みです

<strong>ダウングレード攻撃 = 「古い鍵しか使えません」と嘘をつく</strong>

訪問者が「最新の鍵には対応できません、古い鍵を使ってください」と嘘をつくとします

古い鍵はピッキングしやすいため、訪問者にとって都合がよいわけです

TLS の<strong>ダウングレード攻撃</strong>も同じで、攻撃者が弱い暗号方式の使用を強制しようとする攻撃です

---

## このページで学ぶこと

このページでは、以下の概念を学びます

<strong>TLS のセキュリティ全体像</strong>

- <strong>暗号化技術の組み合わせ</strong>
  - 01-cryptography で学んだ技術が TLS でどう使われるか
- <strong>TLS 1.3 のセキュリティ目標</strong>
  - 機密性、認証、完全性の実現方法

<strong>ハンドシェイクのセキュリティ</strong>

- <strong>各ステップの安全性の根拠</strong>
  - なぜ 1 往復で安全な鍵を共有できるか
- <strong>ハンドシェイクが防ぐ攻撃</strong>
  - 盗聴、改ざん、なりすましへの対策

<strong>鍵導出と前方秘匿性</strong>

- <strong>鍵導出の仕組み</strong>
  - 共有秘密から複数の鍵を安全に作り出す方法
- <strong>前方秘匿性の原理</strong>
  - エフェメラル鍵によるセッション単位の保護

<strong>0-RTT とダウングレード攻撃</strong>

- <strong>0-RTT のリスクと対策</strong>
  - リプレイ攻撃と前方秘匿性の欠如
- <strong>ダウングレード攻撃への防御</strong>
  - 古い暗号方式への強制を防ぐ仕組み

---

## 目次

1. [TLS はなぜ安全か（全体像）](#tls-はなぜ安全か全体像)
2. [ハンドシェイクのセキュリティ](#ハンドシェイクのセキュリティ)
3. [鍵導出の仕組み](#鍵導出の仕組み)
4. [前方秘匿性](#前方秘匿性)
5. [0-RTT のリスクと対策](#0-rtt-のリスクと対策)
6. [ダウングレード攻撃への防御](#ダウングレード攻撃への防御)
7. [TLS が守れないもの](#tls-が守れないもの)
8. [次のトピックへ](#次のトピックへ)
9. [用語集](#用語集)
10. [参考資料](#参考資料)

---

## TLS はなぜ安全か（全体像）

### 暗号化技術の組み合わせ

[01-cryptography](./01-cryptography.md) で学んだ暗号化技術は、TLS 1.3 で以下のように組み合わされています

| 01-cryptography で学んだ技術 | TLS での役割                         | 防ぐ脅威     |
| ---------------------------- | ------------------------------------ | ------------ |
| ECDHE（鍵交換）              | クライアントとサーバーの共有秘密生成 | 盗聴         |
| 対称暗号（AES、ChaCha20）    | 通信データの暗号化                   | 盗聴         |
| AEAD（AES-GCM 等）           | 暗号化と改ざん検出の同時実行         | 盗聴、改ざん |
| ハッシュ関数（SHA-256 等）   | 鍵の導出、ハンドシェイクの完全性確認 | 改ざん       |
| デジタル署名                 | サーバーの身元確認                   | なりすまし   |

これらは個別に使われるのではなく、<strong>連携して</strong>機能します

たとえば、ECDHE だけでは「通信相手が本物か」を確認できません

デジタル署名だけでは「通信データの暗号化」はできません

TLS は、これらすべてを<strong>正しい順序と組み合わせ</strong>で使うことで、安全な通信を実現しています

### TLS 1.3 のセキュリティ目標

RFC 8446 は、TLS が提供する安全なチャネルの特性を以下のように定義しています

<strong>機密性</strong>（Confidentiality）について

> The primary goal of TLS is to provide a secure channel between two communicating peers.

> TLS の主な目的は、通信する 2 つのピア間に安全なチャネルを提供することである

> Data sent over the channel after establishment is only visible to the endpoints.

> 確立後にチャネルを通じて送信されたデータは、エンドポイントにのみ見える

<strong>認証</strong>（Authentication）について

> The server side of the channel is always authenticated; the client side is optionally authenticated.

> チャネルのサーバー側は常に認証される
>
> クライアント側の認証はオプションである

<strong>完全性</strong>（Integrity）について

> Data sent over the channel after establishment cannot be modified by attackers without detection.

> 確立後にチャネルを通じて送信されたデータは、攻撃者が検出されずに改変することはできない

ここで重要なのは、サーバーの認証は<strong>常に行われる</strong>という点です

Web ブラウザで HTTPS サイトにアクセスするとき、サーバーは必ず証明書を提示し、クライアントがそれを検証します

一方、クライアントの認証は<strong>オプション</strong>です

通常の Web アクセスでは、クライアント（ブラウザ）側の証明書は不要です

---

## ハンドシェイクのセキュリティ

### ハンドシェイクの各ステップとセキュリティ上の目的

前のシリーズで学んだ TLS 1.3 ハンドシェイクの流れを、<strong>セキュリティの観点</strong>から見直してみましょう

各ステップには、明確なセキュリティ上の目的があります

| ステップ | メッセージ               | セキュリティ上の目的                           |
| -------- | ------------------------ | ---------------------------------------------- |
| 1        | ClientHello              | 暗号スイートの候補と鍵共有パラメータを提示する |
| 2        | ServerHello              | 暗号スイートを選択し、鍵共有パラメータを返す   |
| 3        | EncryptedExtensions      | サーバーパラメータを暗号化して送る             |
| 4        | Certificate              | サーバーの身元を証明書で証明する               |
| 5        | CertificateVerify        | 秘密鍵の所有を証明する（デジタル署名）         |
| 6        | Finished（サーバー）     | ハンドシェイク全体の改ざんを検出する           |
| 7        | Finished（クライアント） | ハンドシェイク全体の改ざんを検出する           |

ステップ 1 と 2 で鍵共有パラメータが交換され、以降のメッセージはすべて暗号化されます

RFC 8446 はこの点について以下のように述べています

> Everything after the Key Exchange phase is encrypted.

> 鍵交換フェーズ以降のすべてが暗号化される

つまり、ステップ 3 以降の証明書やデジタル署名は暗号化された状態でやり取りされ、<strong>第三者から見えません</strong>

### なぜ 1 往復で安全な鍵を共有できるか

TLS 1.2 では、暗号スイートの合意と鍵交換が別々のステップで行われたため、2 往復が必要でした

TLS 1.3 では、クライアントが ClientHello で<strong>鍵共有パラメータも同時に送る</strong>ことで、1 往復に短縮しました

```
  TLS 1.2（2 往復）：
  クライアント                        サーバー
      │                                  │
      │── ClientHello ──────────────→│  暗号スイートの候補を提示
      │←── ServerHello ─────────────│  暗号スイートの選択
      │←── Certificate ─────────────│  証明書の提示
      │←── ServerKeyExchange ────────│  鍵共有パラメータ（ここで初めて）
      │←── ServerHelloDone ──────────│
      │── ClientKeyExchange ─────────→│  鍵共有パラメータの応答
      │── Finished ──────────────────→│
      │←── Finished ─────────────────│
      │                                  │

  TLS 1.3（1 往復）：
  クライアント                        サーバー
      │                                  │
      │── ClientHello ──────────────→│  暗号スイート＋鍵共有パラメータを同時に提示
      │←── ServerHello ─────────────│  暗号スイート＋鍵共有パラメータを同時に返す
      │←── {暗号化} Certificate ─────│  以降すべて暗号化
      │←── {暗号化} CertificateVerify │
      │←── {暗号化} Finished ────────│
      │── {暗号化} Finished ─────────→│
      │                                  │
```

この仕組みが安全である理由は、[01-cryptography](./01-cryptography.md) で学んだ <strong>Diffie-Hellman 鍵交換</strong>の性質にあります

Diffie-Hellman 鍵交換では、双方が公開値を交換するだけで共有秘密を作り出せます

攻撃者が公開値を傍受しても、共有秘密を求めるには離散対数問題を解く必要があり、これは計算上非常に困難です

TLS 1.3 では ECDHE（楕円曲線 Diffie-Hellman Ephemeral）が使われるため、公開値の交換は 1 往復で完了し、かつその安全性は楕円曲線上の離散対数問題の困難さで保証されています

### 各ステップが防ぐ攻撃

ハンドシェイクの各要素は、特定の攻撃を防ぐために設計されています

| 要素                    | 防ぐ攻撃                 | 仕組み                                               |
| ----------------------- | ------------------------ | ---------------------------------------------------- |
| ECDHE 鍵交換            | 盗聴                     | 攻撃者が通信を傍受しても共有秘密を計算できない       |
| 証明書（Certificate）   | なりすまし               | サーバーの身元を信頼された認証局が保証する           |
| CertificateVerify       | 証明書の不正利用         | 秘密鍵の所有をデジタル署名で証明する                 |
| Finished メッセージ     | ハンドシェイクの改ざん   | ハンドシェイク全体のハッシュを検証する               |
| ランダム値              | リプレイ攻撃             | 毎回異なるランダム値を使い、過去の通信の再利用を防ぐ |
| ステップ 3 以降の暗号化 | ハンドシェイク内容の盗聴 | 証明書情報などが第三者に漏れることを防ぐ             |

<strong>CertificateVerify</strong> が特に重要です

証明書自体は公開情報であり、攻撃者がコピーすることも可能です

しかし、CertificateVerify では、サーバーが<strong>ハンドシェイクの内容に対してデジタル署名</strong>を作成します

この署名を作成するには<strong>秘密鍵</strong>が必要であり、秘密鍵を持たない攻撃者は正しい署名を作れません

つまり、「証明書を持っている」だけでなく「対応する秘密鍵を持っている」ことが証明されます

### Finished メッセージの役割

ハンドシェイクの最後に送られる <strong>Finished メッセージ</strong>は、ハンドシェイク全体の<strong>完全性</strong>を検証する仕組みです

Finished メッセージには、ハンドシェイクで交換されたすべてのメッセージの<strong>ハッシュ値</strong>が含まれています

双方が計算したハッシュ値が一致すれば、ハンドシェイク中にメッセージが<strong>改ざんされていない</strong>ことが確認できます

たとえば、攻撃者が ClientHello の暗号スイート候補を改ざんして弱い暗号方式を追加した場合を考えましょう

クライアントが計算したハッシュ値とサーバーが計算したハッシュ値が一致しなくなり、Finished メッセージの検証で改ざんが検出されます

---

## 鍵導出の仕組み

### なぜ共有秘密をそのまま使わないのか

ECDHE で作り出した共有秘密は、通信データの暗号化にそのまま使われるわけではありません

共有秘密をそのまま暗号鍵として使うと、以下の問題があります

<strong>鍵の使い回しが危険</strong>

1 つの鍵をすべての用途（暗号化、完全性検証、ハンドシェイクの保護など）に使うと、ある用途で鍵が弱点にさらされた場合、すべてが危険になります

<strong>暗号学的な品質の保証が必要</strong>

ECDHE の共有秘密は数学的に生成された値ですが、暗号鍵として使うには追加の処理で<strong>均一な分布</strong>を持つ値に変換する必要があります

そのため、TLS 1.3 では共有秘密から<strong>複数の用途別の鍵</strong>を導出します

### HKDF による鍵導出

TLS 1.3 では、鍵の導出に <strong>HKDF</strong>（HMAC-based Extract-and-Expand Key Derivation Function、RFC 5869）を使用します

HKDF は 2 つのステップで構成されます

<strong>Extract（抽出）</strong>

入力の鍵素材（共有秘密など）から、暗号学的に強い固定長の値を抽出します

共有秘密に偏りがあっても、Extract によって均一な擬似ランダム値に変換されます

<strong>Expand（展開）</strong>

Extract で得られた値を、必要な長さと用途に合わせて<strong>展開</strong>します

展開時に<strong>用途を示すラベル</strong>（たとえば「client handshake traffic」「server application traffic」など）を入力に含めることで、同じ元鍵からでも<strong>用途ごとに異なる鍵</strong>が生成されます

```
  ECDHE 共有秘密
       │
       ▼
  ┌─────────────────┐
  │  HKDF-Extract   │  不均一な共有秘密を均一な値に変換
  └────────┬────────┘
           │
       初期秘密値
           │
           ├──→ HKDF-Expand（ラベル：handshake）──→ ハンドシェイク用鍵
           │
           ├──→ HKDF-Expand（ラベル：traffic）────→ 通信データ用鍵
           │
           └──→ HKDF-Expand（ラベル：resumption）──→ セッション再開用鍵
```

このように、1 つの共有秘密から<strong>目的ごとに独立した鍵</strong>が導出されます

日常の例えで述べた「マスターキーから部屋ごとの鍵を作る」仕組みと同じです

### 鍵の分離

TLS 1.3 では、用途に応じて以下の鍵が導出されます

| 鍵の種類                       | 用途                                 |
| ------------------------------ | ------------------------------------ |
| ハンドシェイクトラフィック鍵   | ハンドシェイクメッセージの暗号化     |
| アプリケーショントラフィック鍵 | ハンドシェイク後の通信データの暗号化 |
| セッション再開用鍵             | 0-RTT や再接続に使う PSK の導出      |

それぞれの鍵は<strong>独立</strong>しています

仮にハンドシェイクトラフィック鍵が何らかの理由で漏洩しても、アプリケーショントラフィック鍵には影響しません

RFC 8446 はこの設計について以下のように述べています

> The new design allows easier analysis by cryptographers due to their improved key separation properties.

> 新しい設計は、鍵分離特性の改善により、暗号学者による分析を容易にする

この「鍵の分離」は、1 つの弱点が全体に波及することを防ぐ<strong>防御の多層化</strong>の考え方に基づいています

### トランスクリプトハッシュ

鍵導出のもう 1 つの重要な要素が<strong>トランスクリプトハッシュ</strong>です

トランスクリプトハッシュとは、ハンドシェイクで交換された<strong>すべてのメッセージ</strong>のハッシュ値です

鍵導出にトランスクリプトハッシュを組み込むことで、以下の効果があります

<strong>ハンドシェイクの完全性と鍵の結合</strong>

導出される鍵は、ハンドシェイクの内容に依存します

もしハンドシェイク中にメッセージが 1 バイトでも改ざんされると、トランスクリプトハッシュが変わり、双方で導出される鍵が異なる値になります

結果として、改ざんされたハンドシェイクからは正しい通信鍵が生成されず、通信が確立できません

```
  クライアント                                サーバー

  ClientHello ──────────────────────→
                                          ServerHello
                                    ←─────────────────
  ┌──────────────────────┐          ┌──────────────────────┐
  │ トランスクリプトハッシュ │          │ トランスクリプトハッシュ │
  │ = hash(ClientHello    │          │ = hash(ClientHello    │
  │      + ServerHello)   │          │      + ServerHello)   │
  └──────────┬───────────┘          └──────────┬───────────┘
             │                                  │
             ▼                                  ▼
       鍵の導出に使用                     鍵の導出に使用

  改ざんがなければ同じハッシュ値 → 同じ鍵が導出される
  改ざんがあれば異なるハッシュ値 → 異なる鍵 → 通信失敗
```

---

## 前方秘匿性

### 前方秘匿性とは

<strong>前方秘匿性</strong>（Forward Secrecy、Perfect Forward Secrecy とも呼ばれる）とは、<strong>長期的な秘密鍵が将来漏洩しても、過去の通信が解読されない</strong>性質です

[01-cryptography](./01-cryptography.md) で学んだように、この性質はエフェメラル鍵（一時鍵）の使用で実現されます

ここでは、その仕組みをプロトコルレベルで詳しく見ていきます

### エフェメラル鍵による前方秘匿性の実現

TLS 1.3 のハンドシェイクでは、ECDHE（楕円曲線 Diffie-Hellman Ephemeral）による鍵交換が行われます

「Ephemeral」の意味は「一時的な」です

クライアントとサーバーは、<strong>接続ごとに新しい一時的な鍵ペア</strong>を生成します

```
  セッション A：
  クライアント                        サーバー
  一時鍵ペア a1 を生成                一時鍵ペア b1 を生成
      │── 公開値 A1 ───────────→│
      │←── 公開値 B1 ──────────│
      共有秘密 S1 を計算              共有秘密 S1 を計算
      a1 を破棄                       b1 を破棄

  セッション B：
  クライアント                        サーバー
  一時鍵ペア a2 を生成                一時鍵ペア b2 を生成
      │── 公開値 A2 ───────────→│
      │←── 公開値 B2 ──────────│
      共有秘密 S2 を計算              共有秘密 S2 を計算
      a2 を破棄                       b2 を破棄
```

セッション A とセッション B では、<strong>まったく異なる一時鍵ペア</strong>が使われます

各セッションの一時的な秘密の値（a1、b1、a2、b2）は使用後に破棄されます

### なぜ過去の通信が安全なのか

サーバーの<strong>長期的な秘密鍵</strong>（証明書に対応する秘密鍵）が漏洩したシナリオを考えましょう

TLS 1.3 では、長期的な秘密鍵は<strong>デジタル署名</strong>（CertificateVerify）にのみ使われます

通信データの暗号化に使われる鍵は、ECDHE のエフェメラル鍵から導出されます

| 漏洩した鍵            | 影響                                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------------------------- |
| サーバーの長期秘密鍵  | 将来のセッションでなりすましが可能（証明書の失効が必要）                                                      |
| サーバーの長期秘密鍵  | <strong>過去の通信データは解読できない</strong>（暗号化鍵はエフェメラル鍵から導出されており、すでに破棄済み） |
| セッション A の一時鍵 | セッション A の通信のみ解読可能                                                                               |
| セッション A の一時鍵 | <strong>セッション B の通信は安全</strong>（異なる一時鍵を使用）                                              |

長期秘密鍵が漏洩しても過去の通信が安全なのは、エフェメラル鍵が<strong>すでに破棄されている</strong>ためです

破棄された鍵は誰にも復元できないため、過去の暗号文を復号する手段がありません

### TLS 1.2 との比較

TLS 1.2 と TLS 1.3 では、前方秘匿性に対するアプローチが大きく異なります

| 項目           | TLS 1.2                                | TLS 1.3                            |
| -------------- | -------------------------------------- | ---------------------------------- |
| 前方秘匿性     | <strong>オプション</strong>            | <strong>必須</strong>              |
| 鍵交換方式     | RSA 鍵交換（前方秘匿性なし）も選択可能 | ECDHE のみ（前方秘匿性が常にある） |
| 暗号化鍵の導出 | 長期秘密鍵から導出する場合がある       | 常にエフェメラル鍵から導出する     |

TLS 1.2 で RSA 鍵交換を使う場合、クライアントはサーバーの公開鍵（長期鍵）でプリマスターシークレットを暗号化して送ります

この方式では、サーバーの長期秘密鍵が漏洩すると、過去に記録された通信のプリマスターシークレットを復号でき、すべての通信データが解読されてしまいます

RFC 8446 はこの改善について以下のように述べています

> All public-key based key exchange mechanisms now provide forward secrecy.

> すべての公開鍵ベースの鍵交換メカニズムが前方秘匿性を提供するようになった

TLS 1.3 では RSA 鍵交換が<strong>廃止</strong>され、ECDHE のみが使用されるため、前方秘匿性が常に保証されています

---

## 0-RTT のリスクと対策

### 0-RTT の仕組み

TLS 1.3 には、以前接続したことのあるサーバーに再接続する際、ハンドシェイクの完了を待たずにデータを送信できる <strong>0-RTT</strong>（Zero Round Trip Time）という機能があります

0-RTT は以下の仕組みで実現されます

1. 初回の接続で、サーバーがクライアントに <strong>PSK</strong>（Pre-Shared Key、事前共有鍵）を発行する
2. 再接続時、クライアントは PSK を使ってデータを暗号化し、ClientHello と同時に送信する
3. サーバーは PSK でデータを復号し、通常のハンドシェイクを並行して進める

```
  通常のハンドシェイク（1-RTT）：
  クライアント                        サーバー
      │── ClientHello ──────────→│
      │←── ServerHello + ... ────│  ← ここまで待つ
      │── Finished ──────────────→│
      │── データ ────────────────→│  ← ここからデータ送信可能

  0-RTT：
  クライアント                        サーバー
      │── ClientHello ──────────→│
      │── 0-RTT データ ──────────→│  ← ハンドシェイク完了前にデータ送信
      │←── ServerHello + ... ────│
      │── Finished ──────────────→│
```

0-RTT により、再接続時の<strong>遅延が削減</strong>されます

しかし、この速さには<strong>セキュリティ上のトレードオフ</strong>が伴います

### リプレイ攻撃のリスク

0-RTT の最大のリスクは、<strong>リプレイ攻撃</strong>に対して脆弱であることです

リプレイ攻撃とは、攻撃者が過去に送信された正規のデータを<strong>再送信</strong>する攻撃です

RFC 8446 はこのリスクを明確に述べています

> There are no guarantees of non-replay between connections.

> 接続間でリプレイされないことの保証はない

たとえば、オンラインバンキングの送金操作を考えましょう

```
  正規の通信：
  クライアント ── 0-RTT「10 万円を送金」──→ サーバー（送金実行）

  リプレイ攻撃：
  攻撃者がこの通信を記録し、再送信する
  攻撃者     ── 0-RTT「10 万円を送金」──→ サーバー（再度送金実行？）
```

攻撃者は暗号化されたデータの中身を読む必要はありません

0-RTT で送信されたデータをそのままコピーして再送信するだけで、同じ操作が再実行される可能性があります

### 前方秘匿性の欠如

0-RTT データにはもう 1 つの重大な制限があります

<strong>前方秘匿性がない</strong>という点です

RFC 8446 はこの点について以下のように述べています

> This data is not forward secret, as it is encrypted solely under keys derived using the offered PSK.

> このデータは前方秘匿性を持たない
>
> 提供された PSK から導出された鍵のみで暗号化されるためである

通常のハンドシェイク後のデータは、ECDHE のエフェメラル鍵から導出された鍵で暗号化されるため前方秘匿性があります

しかし、0-RTT データは ECDHE の鍵交換が完了する<strong>前</strong>に送信されるため、PSK（以前の接続から共有された鍵）のみで暗号化されます

PSK が漏洩した場合、0-RTT で送信されたデータは解読されてしまいます

| データの種類             | 暗号化に使われる鍵         | 前方秘匿性 |
| ------------------------ | -------------------------- | ---------- |
| 0-RTT データ             | PSK から導出した鍵         | なし       |
| ハンドシェイク後のデータ | ECDHE + PSK から導出した鍵 | あり       |

### 0-RTT の対策

0-RTT のリスクに対して、以下の対策が推奨されています

<strong>べき等でない操作の制限</strong>

0-RTT で送信するデータは、<strong>べき等</strong>（何回実行しても同じ結果になる）な操作に限定すべきです

たとえば、Web ページの取得（GET リクエスト）はべき等ですが、送金（POST リクエスト）はべき等ではありません

| 操作の種類   | べき等か     | 0-RTT での送信 |
| ------------ | ------------ | -------------- |
| ページの取得 | べき等       | 適切           |
| 検索クエリ   | べき等       | 適切           |
| 送金操作     | べき等でない | 不適切         |
| 注文確定     | べき等でない | 不適切         |

<strong>サーバー側のリプレイ防止</strong>

サーバーは、0-RTT データが再送信されていないことを確認する仕組みを実装できます

たとえば、0-RTT データに含まれるタイムスタンプや一意な識別子を記録し、同じデータが再送された場合は拒否する方法があります

<strong>0-RTT の無効化</strong>

セキュリティを最優先する場合、サーバーは 0-RTT 自体を無効にできます

0-RTT はあくまで<strong>オプション機能</strong>であり、すべてのサーバーが受け入れる必要はありません

---

## ダウングレード攻撃への防御

### ダウングレード攻撃とは

<strong>ダウングレード攻撃</strong>とは、攻撃者が通信の中間に介入し、クライアントとサーバーに<strong>弱い暗号方式やプロトコルバージョンの使用</strong>を強制する攻撃です

たとえば、クライアントとサーバーの両方が TLS 1.3 に対応しているにもかかわらず、攻撃者が「TLS 1.2 しか対応していない」と偽ることで、TLS 1.2 での接続を強制する可能性があります

TLS 1.2 には前方秘匿性がオプションであるなど、TLS 1.3 と比べてセキュリティが弱い面があるため、攻撃者はそれを利用して通信を解読しようとします

### TLS 1.3 の防御メカニズム

TLS 1.3 には、ダウングレード攻撃を検出するための巧妙な仕組みが組み込まれています

<strong>ServerHello のランダム値によるセンチネル値</strong>

RFC 8446 は以下のように規定しています

> TLS 1.3 servers which negotiate TLS 1.2 or below MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01

> TLS 1.3 サーバーが TLS 1.2 以下をネゴシエートする場合、ランダム値の末尾 8 バイトを 44 4F 57 4E 47 52 44 01 に設定しなければならない

この 8 バイトは ASCII で「DOWNGRD」+ 0x01 を表します

TLS 1.3 に対応するクライアントは、ServerHello を受け取ったときにこのセンチネル値を確認します

もし TLS 1.2 での接続が提案された ServerHello にこのセンチネル値が含まれていれば、サーバーは本来 TLS 1.3 に対応しているが<strong>何らかの理由で</strong>ダウングレードされたことが分かります

この場合、クライアントは接続を<strong>中止</strong>します

```
  正常な TLS 1.3 接続：
  クライアント ── ClientHello（TLS 1.3 対応）──→ サーバー
  クライアント ←── ServerHello（TLS 1.3）────── サーバー
  → TLS 1.3 で接続（問題なし）

  ダウングレード攻撃の検出：
  クライアント ── ClientHello（TLS 1.3 対応）──→ 攻撃者 ──→ サーバー
  クライアント ←── ServerHello（TLS 1.2）────── 攻撃者 ←── サーバー
  → サーバーのランダム値末尾に「DOWNGRD」が含まれる
  → クライアントがダウングレード攻撃を検出し、接続を中止
```

### 暗号スイートの制限による防御

TLS 1.3 では、もう 1 つのダウングレード防御策として、<strong>脆弱な暗号方式の廃止</strong>があります

TLS 1.2 では多数の暗号スイートが使用可能で、その中には安全性が不十分なものも含まれていました

TLS 1.3 では使用できる暗号スイートが大幅に制限され、安全なものだけが残されています

| 項目                 | TLS 1.2            | TLS 1.3 |
| -------------------- | ------------------ | ------- |
| 暗号スイートの数     | 数十種類以上       | 5 種類  |
| RSA 鍵交換           | 使用可能           | 廃止    |
| RC4、DES             | 使用可能（非推奨） | 廃止    |
| 前方秘匿性のない方式 | 使用可能           | 廃止    |
| AEAD 以外の方式      | 使用可能           | 廃止    |

暗号スイートを少数に絞ることで、攻撃者が弱い暗号方式を選択させる余地がなくなります

---

## TLS が守れないもの

TLS は通信の安全性を大幅に向上させますが、<strong>万能ではありません</strong>

TLS が守れないものを理解することは、セキュリティ全体を考える上で重要です

### メタデータの漏洩

TLS が暗号化するのは<strong>通信の内容</strong>（HTTP リクエスト、レスポンスなど）です

しかし、以下のメタデータは暗号化されず、通信経路上で見えます

| メタデータ       | 見える理由                                  |
| ---------------- | ------------------------------------------- |
| IP アドレス      | IP ヘッダは TLS の暗号化対象外              |
| ポート番号       | TCP ヘッダは TLS の暗号化対象外             |
| 通信のタイミング | パケットの送受信タイミングは暗号化できない  |
| データサイズ     | TLS レコードのヘッダにデータ長が含まれる    |
| 接続先ドメイン名 | SNI（後述）により平文で送信される場合がある |

つまり、「誰が」「いつ」「どのくらいの量」通信しているかは、TLS では隠せません

「何を」通信しているかは暗号化で保護されますが、通信の存在自体は隠せないのです

### SNI によるドメイン名の漏洩

<strong>SNI</strong>（Server Name Indication）は、ClientHello にクライアントが接続したいドメイン名を含める仕組みです

1 つの IP アドレスで複数のドメインをホストしているサーバーが、どの証明書を提示すべきか判断するために使われます

この SNI は TLS ハンドシェイクの<strong>暗号化が始まる前</strong>に送信されるため、通信経路上の第三者が接続先のドメイン名を知ることができます

この問題を解決するために <strong>Encrypted Client Hello</strong>（ECH）という仕組みが提案されています

ECH は ClientHello の SNI を含む部分を暗号化することで、接続先ドメイン名の漏洩を防ぎます

### TLS はエンドポイントを守らない

TLS は<strong>通信路</strong>（クライアントとサーバーの間のネットワーク）を保護します

しかし、通信の<strong>端点</strong>（クライアントやサーバーそのもの）のセキュリティは TLS の範囲外です

| 脅威                                               | TLS で防げるか |
| -------------------------------------------------- | -------------- |
| 通信経路上の盗聴                                   | 防げる         |
| 通信経路上の改ざん                                 | 防げる         |
| サーバーへのなりすまし                             | 防げる         |
| クライアントのマルウェア感染                       | 防げない       |
| サーバーへの不正アクセス                           | 防げない       |
| フィッシング（正規の証明書を持つ偽サイト）         | 防げない       |
| アプリケーションの脆弱性（SQL インジェクション等） | 防げない       |

TLS は「通信路を安全にするプロトコル」であり、「すべてのセキュリティ問題を解決するもの」ではありません

TLS で安全な通信路を確保した上で、アプリケーションレベルのセキュリティ対策も必要です

アプリケーションレベルの脆弱性については [06-application-security](./06-application-security.md) で学びます

---

## 次のトピックへ

このトピックでは、以下のことを学びました

- TLS 1.3 は対称暗号、非対称暗号、ハッシュ関数、鍵交換、AEAD を組み合わせて安全な通信を実現している
- ハンドシェイクの各ステップには明確なセキュリティ上の目的があり、1 往復で安全な鍵共有が可能な理由は Diffie-Hellman 鍵交換の性質にある
- HKDF による鍵導出で、1 つの共有秘密から用途ごとに独立した鍵が生成され、鍵の分離が実現されている
- 前方秘匿性はエフェメラル鍵の使用で実現され、TLS 1.3 では必須化された
- 0-RTT は速度と引き換えにリプレイ攻撃のリスクと前方秘匿性の欠如を伴う
- ダウングレード攻撃はセンチネル値と暗号スイートの制限で防御される
- TLS は通信路を保護するが、メタデータの漏洩やエンドポイントのセキュリティは範囲外である

しかし、ここで重要な疑問が残ります

TLS ハンドシェイクではサーバーが証明書を提示しますが、<strong>なぜその証明書を信頼できるのでしょうか</strong>？

証明書を発行する認証局は、どのように信頼されるのでしょうか？

もし認証局が不正な証明書を発行してしまったら、どうなるのでしょうか？

証明書の有効期限が切れたり、秘密鍵が漏洩して証明書を失効させる必要がある場合、どのような仕組みが使われるのでしょうか？

次のトピック [03-certificate](./03-certificate.md) では、<strong>証明書と PKI（信頼の連鎖）</strong>の仕組みを学びます

---

## 用語集

| 用語                                                  | 説明                                                                                                             |
| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| TLS（Transport Layer Security）                       | TCP の上で通信を暗号化するプロトコル。暗号化、認証、完全性の 3 つの保護を提供する                                |
| TLS 1.3                                               | 2018 年に RFC 8446 で標準化された TLS の最も安全なバージョン。前方秘匿性が必須化され、暗号スイートが厳選された   |
| 前方秘匿性（Forward Secrecy）                         | 長期的な秘密鍵が将来漏洩しても、過去の通信が解読されない性質。エフェメラル鍵の使用で実現する                     |
| エフェメラル鍵（Ephemeral Key）                       | 通信セッションごとに生成し、使い終わったら破棄する一時的な鍵                                                     |
| ECDHE                                                 | Elliptic Curve Diffie-Hellman Ephemeral の略。楕円曲線を使った一時鍵による鍵交換方式。TLS 1.3 で標準的に使われる |
| HKDF                                                  | HMAC-based Extract-and-Expand Key Derivation Function の略。共有秘密から暗号鍵を導出するための関数（RFC 5869）   |
| HKDF-Extract                                          | HKDF の第 1 段階。入力の鍵素材から暗号学的に強い固定長の値を抽出する                                             |
| HKDF-Expand                                           | HKDF の第 2 段階。抽出された値を用途に合わせた長さの鍵に展開する                                                 |
| 鍵導出（Key Derivation）                              | 共有秘密や初期鍵素材から、暗号化に使用する鍵を数学的に生成するプロセス                                           |
| 鍵の分離（Key Separation）                            | 用途ごとに独立した鍵を使用する設計原則。1 つの鍵の漏洩が他の鍵に影響しないようにする                             |
| トランスクリプトハッシュ（Transcript Hash）           | ハンドシェイクで交換されたすべてのメッセージのハッシュ値。鍵導出に組み込むことでハンドシェイクの完全性を保証する |
| ハンドシェイクトラフィック鍵                          | ハンドシェイクメッセージの暗号化に使用される鍵                                                                   |
| アプリケーショントラフィック鍵                        | ハンドシェイク完了後の通信データの暗号化に使用される鍵                                                           |
| 0-RTT（Zero Round Trip Time）                         | TLS 1.3 で再接続時にハンドシェイク完了前にデータを送信する仕組み。速度と引き換えにセキュリティリスクを伴う       |
| PSK（Pre-Shared Key）                                 | 以前の接続で共有された鍵。0-RTT 再開やセッション再開に使用される                                                 |
| リプレイ攻撃（Replay Attack）                         | 攻撃者が過去に送信された正規のデータを再送信する攻撃。0-RTT データが特に脆弱                                     |
| べき等（Idempotent）                                  | 何回実行しても同じ結果になる操作の性質。GET リクエストはべき等、送金操作はべき等でない                           |
| ダウングレード攻撃（Downgrade Attack）                | 攻撃者が弱い暗号方式やプロトコルバージョンの使用を強制する攻撃                                                   |
| センチネル値（Sentinel Value）                        | 特定の状態を検出するために埋め込まれる特別な値。TLS 1.3 ではダウングレード検出に使われる                         |
| ClientHello                                           | TLS ハンドシェイクの最初のメッセージ。暗号スイートの候補と鍵共有パラメータを含む                                 |
| ServerHello                                           | サーバーが暗号スイートを選択して返すメッセージ。鍵共有パラメータを含む                                           |
| CertificateVerify                                     | サーバーがハンドシェイクの内容にデジタル署名を付けるメッセージ。秘密鍵の所有を証明する                           |
| Finished                                              | ハンドシェイクの完全性を確認する最後のメッセージ。すべてのメッセージのハッシュ値を含む                           |
| 暗号スイート（Cipher Suite）                          | TLS で使用する暗号アルゴリズムの組み合わせ。TLS 1.3 では 5 種類に制限されている                                  |
| SNI（Server Name Indication）                         | ClientHello に含まれる接続先ドメイン名。暗号化されていないため第三者に見える                                     |
| Encrypted Client Hello（ECH）                         | ClientHello の SNI 等を暗号化する仕組み。接続先ドメイン名の漏洩を防ぐ                                            |
| 機密性（Confidentiality）                             | 許可された人だけがデータを読める状態を保証する性質                                                               |
| 認証（Authentication）                                | 通信相手が主張する身元のとおりであることを確認すること                                                           |
| 完全性（Integrity）                                   | データが改ざんされていないことを確認できる性質                                                                   |
| 証明書（Certificate）                                 | サーバーの身元と公開鍵を含む電子的な文書。認証局が発行する。詳細は 03-certificate で学ぶ                         |
| デジタル署名                                          | 秘密鍵でデータに署名し、公開鍵で検証する仕組み。データの真正性と完全性を確認できる                               |
| AEAD（Authenticated Encryption with Associated Data） | 暗号化と改ざん検出を 1 つの操作で同時に行う方式。TLS 1.3 ではすべての暗号スイートが AEAD を採用                  |
| RSA 鍵交換                                            | TLS 1.2 以前で使われた鍵交換方式。サーバーの長期公開鍵で暗号化するため前方秘匿性がない。TLS 1.3 で廃止           |
| プリマスターシークレット                              | TLS 1.2 の RSA 鍵交換でクライアントが生成する秘密値。サーバーの公開鍵で暗号化して送信する                        |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>TLS プロトコル仕様</strong>

- [RFC 8446 - The Transport Layer Security (TLS) Protocol Version 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
  - TLS 1.3 の仕様（ハンドシェイクのセキュリティ、鍵スケジュール、前方秘匿性、0-RTT、ダウングレード防御）

- [RFC 5246 - The Transport Layer Security (TLS) Protocol Version 1.2](https://datatracker.ietf.org/doc/html/rfc5246)
  - TLS 1.2 の仕様（TLS 1.3 との比較に使用）

<strong>鍵導出</strong>

- [RFC 5869 - HMAC-based Extract-and-Expand Key Derivation Function (HKDF)](https://datatracker.ietf.org/doc/html/rfc5869)
  - TLS 1.3 の鍵導出に使用される HKDF の仕様

<strong>暗号化標準</strong>

- [NIST SP 800-175B Rev. 1 - Guideline for Using Cryptographic Standards](https://csrc.nist.gov/pubs/sp/800/175/b/r1/final)
  - 暗号化標準の使用ガイドライン（暗号方式の推奨、鍵管理の原則）
